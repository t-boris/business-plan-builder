---
phase: 07-generic-scenario-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/store/scenario-atoms.ts, src/store/derived-atoms.ts, src/types/scenario.ts, src/types/index.ts]
autonomous: true
---

<objective>
Add dynamic atom architecture alongside existing hardcoded atoms. This is the foundation for the entire Phase 7 migration: a single Record atom for scenario values plus a derived evaluation atom powered by the Phase 6 formula engine.

Purpose: Establish the new atom layer that all subsequent plans depend on, without breaking any existing functionality. Old atoms remain intact for backward compatibility during migration.
Output: New dynamic atoms (scenarioValuesAtom, evaluatedValuesAtom, snapshotInputValuesAtom, loadDynamicScenarioAtom, resetDynamicToDefaultsAtom) and DynamicScenario type.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-generic-scenario-engine/07-RESEARCH.md

@src/store/scenario-atoms.ts
@src/store/derived-atoms.ts
@src/store/business-atoms.ts
@src/lib/formula-engine.ts
@src/types/scenario.ts
@src/types/business.ts
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dynamic atoms to scenario-atoms.ts and derived-atoms.ts</name>
  <files>src/store/scenario-atoms.ts, src/store/derived-atoms.ts</files>
  <action>
  **In scenario-atoms.ts — ADD these atoms after the existing management atoms (keep ALL old atoms intact):**

  1. `scenarioValuesAtom`: `atom<Record<string, number>>({})` — stores current scenario's input variable values, keyed by variable ID.

  2. `snapshotInputValuesAtom`: Read-only atom that filters scenarioValuesAtom to only input variable values. Reads `businessVariablesAtom` from `@/store/business-atoms.ts` to know which variables are inputs. For each input variable, return `scenarioValuesAtom[id] ?? def.value` (fall back to default). Returns `{}` if definitions are null.

  3. `loadDynamicScenarioAtom`: Writable atom `atom<null, [DynamicScenario], void>` that sets scenarioNameAtom, currentScenarioIdAtom, and scenarioValuesAtom from a DynamicScenario object. Import DynamicScenario from `@/types`.

  4. `resetDynamicToDefaultsAtom`: Writable atom `atom<null, [], void>` that reads `businessVariablesAtom` to build default input values (`def.defaultValue` for each input variable), then sets scenarioNameAtom to 'New Scenario', currentScenarioIdAtom to `crypto.randomUUID()`, and scenarioValuesAtom to the defaults object.

  Import `businessVariablesAtom` from `@/store/business-atoms.ts`. Import `DynamicScenario` from `@/types`.

  **In derived-atoms.ts — ADD evaluatedValuesAtom after existing derived atoms (keep ALL old atoms intact):**

  5. `evaluatedValuesAtom`: Read-only atom that:
     - Reads `businessVariablesAtom` from business-atoms.ts and `scenarioValuesAtom` from scenario-atoms.ts
     - Returns `{}` if definitions are null
     - Creates a merged copy of definitions where each input variable's `.value` is overridden by `scenarioValuesAtom[id] ?? def.value`
     - Calls `evaluateVariables(merged)` from `@/lib/formula-engine.ts`
     - On error (circular dependency), returns a fallback object with just the raw `.value` from each merged definition
     - Returns `Record<string, number>` (all variable IDs → evaluated values)

  Import `evaluateVariables` from `@/lib/formula-engine.ts`. Import `businessVariablesAtom` from business-atoms.ts. Import `scenarioValuesAtom` from scenario-atoms.ts. Import `VariableDefinition` from `@/types`.

  **CRITICAL:** Do NOT remove or modify any existing atoms. This task is purely additive. The old priceTier1Atom, snapshotScenarioAtom, loadScenarioAtom, resetToDefaultsAtom, and all derived atoms (monthlyBookingsAtom etc.) must remain untouched.
  </action>
  <verify>Grep for `scenarioValuesAtom`, `evaluatedValuesAtom`, `snapshotInputValuesAtom`, `loadDynamicScenarioAtom`, `resetDynamicToDefaultsAtom` in the source files to confirm they exist. Verify old atoms still present by grepping for `priceTier1Atom` and `monthlyBookingsAtom`.</verify>
  <done>All 5 new atoms exported from their respective files. All old atoms remain intact. No circular import issues.</done>
</task>

<task type="auto">
  <name>Task 2: Add DynamicScenario type and export</name>
  <files>src/types/scenario.ts, src/types/index.ts</files>
  <action>
  **In types/scenario.ts — ADD after existing types (keep ScenarioVariables, Scenario, DerivedMetrics intact):**

  ```
  DynamicScenario {
    metadata: ScenarioMetadata;   // reuse existing type (id, name, description, createdAt, isBaseline)
    values: Record<string, number>;  // only input variable values, keyed by variable ID
  }
  ```

  **In types/index.ts — ADD DynamicScenario to the scenario.ts export line:**

  Add `DynamicScenario` to the existing export list from `'./scenario.ts'`.

  **CRITICAL:** Do NOT remove ScenarioVariables, Scenario, or DerivedMetrics. They are still used by existing code until Plan 07-04 removes them.
  </action>
  <verify>Grep for `DynamicScenario` in types/scenario.ts and types/index.ts to confirm the type exists and is exported.</verify>
  <done>DynamicScenario type defined and exported. All old types remain intact. Types can be imported as `import type { DynamicScenario } from '@/types'`.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes (no compile errors — all changes are additive)
- [ ] New atoms are importable: scenarioValuesAtom, evaluatedValuesAtom, snapshotInputValuesAtom, loadDynamicScenarioAtom, resetDynamicToDefaultsAtom
- [ ] DynamicScenario type is importable from @/types
- [ ] Old atoms and types still exist and are unchanged
</verification>

<success_criteria>

- All 5 new atoms added and exported
- DynamicScenario type added and exported
- No existing code broken (all additive)
- TypeScript compiles without errors
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/07-generic-scenario-engine/07-01-SUMMARY.md`
</output>
