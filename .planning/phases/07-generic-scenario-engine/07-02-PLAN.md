---
phase: 07-generic-scenario-engine
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified: [src/lib/business-firestore.ts, src/hooks/use-scenario-sync.ts, src/app/providers.tsx, src/features/scenarios/scenario-manager.tsx]
autonomous: true
---

<objective>
Migrate the scenario persistence layer to use dynamic atoms and DynamicScenario type. Rewrite the sync hook, provider ScenarioSync component, and ScenarioManager to save/load dynamic variable values instead of the 10 hardcoded ScenarioVariables fields.

Purpose: Wire the new dynamic atoms (from Plan 07-01) into the Firestore save/load pipeline. After this plan, scenarios are saved as `{ metadata, values: Record<string, number> }` instead of `{ metadata, variables: ScenarioVariables }`.
Output: Updated Firestore functions, rewritten useScenarioSync hook, updated ScenarioSync provider component, updated ScenarioManager.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-generic-scenario-engine/07-RESEARCH.md
@.planning/phases/07-generic-scenario-engine/07-01-SUMMARY.md

@src/lib/business-firestore.ts
@src/hooks/use-scenario-sync.ts
@src/app/providers.tsx
@src/features/scenarios/scenario-manager.tsx
@src/store/scenario-atoms.ts
@src/store/business-atoms.ts
@src/types/scenario.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Firestore scenario functions and rewrite useScenarioSync</name>
  <files>src/lib/business-firestore.ts, src/hooks/use-scenario-sync.ts</files>
  <action>
  **In business-firestore.ts — Update the legacy scenario functions (lines ~440-525) to use DynamicScenario:**

  1. Change `saveScenarioData` signature from `(businessId: string, scenario: Scenario)` to `(businessId: string, scenario: DynamicScenario)`. The doc path stays the same: `businesses/{businessId}/scenarios/{scenario.metadata.id}`. The save logic stays the same (setDoc with merge).

  2. Change `listScenarioData` return type from `Promise<Scenario[]>` to `Promise<DynamicScenario[]>`. The cast changes from `as Scenario` to `as DynamicScenario`.

  3. Change `getScenarioData` return type from `Promise<Scenario | null>` to `Promise<DynamicScenario | null>`.

  4. Update imports: Replace `Scenario` import with `DynamicScenario` from `@/types`. Keep all other imports.

  5. `deleteScenarioData` — no change needed (only takes businessId + scenarioId).
  6. `getScenarioPreferences` / `saveScenarioPreferences` — no change needed.

  **In use-scenario-sync.ts — Complete rewrite to use dynamic atoms:**

  Replace the entire file. The new hook:
  - Imports: `snapshotInputValuesAtom`, `scenarioNameAtom`, `currentScenarioIdAtom`, `scenarioListAtom`, `scenarioSyncReadyAtom` from scenario-atoms.ts. Import `activeBusinessIdAtom` from business-atoms.ts. Import `saveScenarioData`, `saveScenarioPreferences` from business-firestore.ts. Import `DynamicScenario` from types.
  - Reads `snapshotInputValuesAtom` (NOT snapshotScenarioAtom) to get current input values as Record<string, number>.
  - Auto-save effect: Same 500ms debounce pattern as current. When syncReady and businessId are truthy, build a DynamicScenario: `{ metadata: { id: currentId, name: scenarioName, description, createdAt, isBaseline }, values: inputValues }`. Call `saveScenarioData(businessId, scenario)` and `saveScenarioPreferences`. Update scenarioListAtom metadata.
  - Key difference: `scenario.values` is `Record<string, number>` (from snapshotInputValuesAtom), NOT `ScenarioVariables`.
  - Keep the same error handling: silently catch Firestore errors.
  - Keep the `scenarioList.find(m => m.id === currentId)` pattern for preserving existing metadata fields.
  </action>
  <verify>Grep for `DynamicScenario` in business-firestore.ts and use-scenario-sync.ts. Verify snapshotInputValuesAtom is imported (not snapshotScenarioAtom). Verify no imports of the old `Scenario` type or `snapshotScenarioAtom` remain in these two files.</verify>
  <done>Firestore functions accept/return DynamicScenario. Sync hook saves input values as Record<string, number>. No references to old Scenario type or snapshotScenarioAtom in modified files.</done>
</task>

<task type="auto">
  <name>Task 2: Rewrite ScenarioSync provider and ScenarioManager</name>
  <files>src/app/providers.tsx, src/features/scenarios/scenario-manager.tsx</files>
  <action>
  **In providers.tsx — Rewrite the ScenarioSync component:**

  1. Update imports: Replace `loadScenarioAtom` with `loadDynamicScenarioAtom`. Replace `DEFAULT_SCENARIO_VARIABLES` import from constants. Add `businessVariablesAtom` from business-atoms.ts. Import `DynamicScenario` from types.

  2. Rewrite the `init()` function inside ScenarioSync:
     - Call `listScenarioData(businessId)` — now returns `DynamicScenario[]`.
     - **If no scenarios exist:** Build baseline from variable definitions. Read `businessVariablesAtom` using `store.get()` — but since this is a component, use a ref or pass from parent. SIMPLER: get variables from the store. Actually, ScenarioSync is a component, not a hook. It can use `useAtomValue(businessVariablesAtom)` to get current variable definitions. Build default values: iterate definitions, for each input variable, use `def.defaultValue`. Create baseline: `{ metadata: { id: 'baseline', name: 'Baseline', description: '', createdAt: ISO, isBaseline: true }, values: defaultInputValues }`. Save to Firestore and load via `loadDynamicScenario(baseline)`.
     - **If scenarios exist:** Same flow as current — find active scenario from preferences, load it via `loadDynamicScenario(target)`.
     - Remove the `bookingsPerMonth` calculation and `DEFAULT_SCENARIO_VARIABLES` usage.
     - Keep the `prevBusinessIdRef` pattern for business change detection.
     - Keep the `scenarioSyncReadyAtom` gating pattern.

  3. Remove unused imports: `DEFAULT_SCENARIO_VARIABLES` from constants, `Scenario` type, old `loadScenarioAtom`.

  4. Add `businessVariablesAtom` and `businessVariablesLoadedAtom` reads. Gate ScenarioSync init on variables being loaded: add check `if (!variablesLoaded) return;` before the scenario init logic. This ensures variable definitions are available when creating baseline defaults.

  **In scenario-manager.tsx — Update to use dynamic atoms:**

  1. Replace imports: `loadScenarioAtom` → `loadDynamicScenarioAtom`, `resetToDefaultsAtom` → `resetDynamicToDefaultsAtom`.

  2. `handleSwitch`: Call `listScenarioData(businessId)` (now returns DynamicScenario[]). Find target by ID. Call `loadDynamicScenario(target)` instead of `loadScenario(target)`.

  3. `handleNew`: Call `resetDynamicToDefaults()` instead of `resetToDefaults()`.

  4. No other changes needed — the Select dropdown, delete, and UI remain the same.
  </action>
  <verify>Grep for `loadDynamicScenarioAtom` and `resetDynamicToDefaultsAtom` in providers.tsx and scenario-manager.tsx. Verify no imports of `DEFAULT_SCENARIO_VARIABLES`, old `loadScenarioAtom`, or old `resetToDefaultsAtom` remain in these files. Verify `businessVariablesAtom` is imported in providers.tsx.</verify>
  <done>ScenarioSync creates baseline from variable definitions (not hardcoded defaults). ScenarioManager uses dynamic load/reset atoms. No references to old atoms or DEFAULT_SCENARIO_VARIABLES in modified files.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] No TypeScript errors in the 4 modified files (individual file check — full build may have errors in unmodified files that still import old atoms)
- [ ] `saveScenarioData` accepts DynamicScenario type
- [ ] `useScenarioSync` uses snapshotInputValuesAtom
- [ ] ScenarioSync creates baseline from businessVariablesAtom defaults
- [ ] ScenarioManager uses loadDynamicScenarioAtom and resetDynamicToDefaultsAtom
</verification>

<success_criteria>

- All 4 files updated with dynamic atom usage
- Firestore functions typed for DynamicScenario
- Sync hook saves Record<string, number> values
- Provider creates baseline from variable definitions
- Manager uses dynamic load/reset
- No references to old Scenario type, DEFAULT_SCENARIO_VARIABLES, snapshotScenarioAtom, loadScenarioAtom, or resetToDefaultsAtom in modified files
</success_criteria>

<output>
After completion, create `.planning/phases/07-generic-scenario-engine/07-02-SUMMARY.md`
</output>
