---
phase: 03-dynamic-business-context
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/lib/business-firestore.ts, src/hooks/use-section.ts, src/hooks/use-scenario-sync.ts, src/app/providers.tsx, src/features/scenarios/scenario-manager.tsx, src/store/plan-atoms.ts, src/lib/firestore.ts]
autonomous: true
---

<objective>
Wire all data-layer hooks and providers to use the dynamic business ID from `activeBusinessIdAtom` instead of the hardcoded `currentPlanIdAtom('default')`. Replace all imports from the old `firestore.ts` (which uses `plans/{planId}/` paths) with business-scoped Firestore operations under `businesses/{businessId}/`.

Purpose: After this plan, switching businesses (via `activeBusinessIdAtom`) causes all section data and scenario data to load from the correct business-scoped Firestore paths. This is the data-layer foundation that Phase 3's routing (Plan 03-02) builds upon.
Output: Updated hooks and providers that are fully business-aware. Old `plan-atoms.ts` and `firestore.ts` deleted.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-dynamic-business-context/03-CONTEXT.md

@src/store/plan-atoms.ts
@src/store/business-atoms.ts
@src/store/scenario-atoms.ts
@src/lib/firestore.ts
@src/lib/business-firestore.ts
@src/hooks/use-section.ts
@src/hooks/use-scenario-sync.ts
@src/app/providers.tsx
@src/features/scenarios/scenario-manager.tsx
@src/types/scenario.ts
@src/types/business.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add section/scenario data functions to business-firestore.ts and migrate useSection hook</name>
  <files>src/lib/business-firestore.ts, src/hooks/use-section.ts, src/store/plan-atoms.ts, src/lib/firestore.ts</files>
  <action>
  **Step 1: Add transitional data functions to `business-firestore.ts`.**

  The existing `getBusinessSection`/`saveBusinessSection` work with the `BusinessSection` wrapper type (which has `data`, `schema`, `label`, `order` fields). But the current `useSection` hook reads/writes raw section data (e.g., `ExecutiveSummary` object stored directly as document fields). Phase 5 will migrate to the full `BusinessSection` format; for Phase 3, add thin functions that store raw section data at the business-scoped path:

  ```typescript
  // --- Section Data (raw format for useSection hook) ---
  // Stores raw section data directly at businesses/{businessId}/sections/{sectionKey}
  // Phase 5 will migrate to full BusinessSection format with schema/order/label wrapper.

  export async function getSectionData<T>(
    businessId: string,
    sectionKey: string
  ): Promise<T | null> {
    const snap = await getDoc(doc(db, 'businesses', businessId, 'sections', sectionKey));
    if (!snap.exists()) return null;
    return snap.data() as T;
  }

  export async function saveSectionData(
    businessId: string,
    sectionKey: string,
    data: object
  ): Promise<void> {
    await setDoc(
      doc(db, 'businesses', businessId, 'sections', sectionKey),
      data,
      { merge: true }
    );
  }
  ```

  Also add scenario data functions that work with the existing `Scenario` type (from `types/scenario.ts`) at business-scoped paths. Phase 7 will migrate to the `BusinessScenario` type with `Record<string, VariableDefinition>` variables; for Phase 3, keep the typed `ScenarioVariables`:

  ```typescript
  // --- Scenario Data (legacy Scenario type for useScenarioSync) ---
  // Uses existing Scenario type at businesses/{businessId}/scenarios/{scenarioId}
  // Phase 7 will migrate to BusinessScenario with dynamic VariableDefinition variables.

  import type { Scenario } from '@/types';

  export async function getScenarioData(businessId: string, scenarioId: string): Promise<Scenario | null>
  export async function saveScenarioData(businessId: string, scenario: Scenario): Promise<void>
  export async function listScenarioData(businessId: string): Promise<Scenario[]>
  export async function deleteScenarioData(businessId: string, scenarioId: string): Promise<void>
  export async function getScenarioPreferences(businessId: string): Promise<{ activeScenarioId: string } | null>
  export async function saveScenarioPreferences(businessId: string, state: { activeScenarioId: string }): Promise<void>
  ```

  Implement these following the same patterns as the existing `getBusinessSection`/`saveBusinessSection` but using `Scenario` type. The preferences path is `businesses/{businessId}/state/preferences`.

  **Step 2: Migrate `useSection` hook.**

  In `src/hooks/use-section.ts`:
  - Replace `import { currentPlanIdAtom } from '@/store/plan-atoms'` with `import { activeBusinessIdAtom } from '@/store/business-atoms'`
  - Replace `import { getSection, saveSection } from '@/lib/firestore'` with `import { getSectionData, saveSectionData } from '@/lib/business-firestore'`
  - Change `const planId = useAtomValue(currentPlanIdAtom)` to `const businessId = useAtomValue(activeBusinessIdAtom)`
  - Guard all Firestore calls with `if (!businessId) return` — when no business is selected, use defaults and skip loading/saving
  - In the load effect: call `getSectionData<T>(businessId, sectionSlug)` instead of `getSection<T>(planId, sectionSlug)`
  - In `debounceSave`: call `saveSectionData(businessId, sectionSlug, newData)` instead of `saveSection(planId, ...)`
  - In flush-on-unmount: same replacement
  - The `isLoading` state should immediately become `false` if `businessId` is null (no business = use defaults)
  - Keep `businessId` in the load effect dependency array so data reloads when business changes
  - When businessId changes: reset data to defaults and reload. Add `setData(defaultData)` before the async load to clear stale data from the previous business.

  **Step 3: Delete old files.**
  - Delete `src/store/plan-atoms.ts` entirely. The `sectionDataMapAtom` and `sectionDataAtom` defined there are unused (never imported anywhere).
  - Delete `src/lib/firestore.ts` — all its consumers will be migrated (useSection in this task, scenario files in Task 2).
  </action>
  <verify>Run `npx tsc --noEmit` to verify no TypeScript errors after migration. Check that no files import from `@/store/plan-atoms` or `@/lib/firestore`.</verify>
  <done>
  - `useSection` reads/writes from `businesses/{businessId}/sections/{sectionKey}` path
  - `useSection` gracefully handles null businessId (shows defaults, no Firestore calls)
  - `useSection` reloads data when businessId changes
  - `plan-atoms.ts` deleted
  - `firestore.ts` deleted (may still have scenario imports from Task 2 — that's OK, Task 2 finishes the migration)
  - New `getSectionData`/`saveSectionData` + scenario data functions exported from `business-firestore.ts`
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate scenario layer to business-scoped Firestore (useScenarioSync, ScenarioSync, ScenarioManager)</name>
  <files>src/hooks/use-scenario-sync.ts, src/app/providers.tsx, src/features/scenarios/scenario-manager.tsx</files>
  <action>
  **Step 1: Migrate `useScenarioSync` hook.**

  In `src/hooks/use-scenario-sync.ts`:
  - Replace `import { currentPlanIdAtom } from '@/store/plan-atoms'` with `import { activeBusinessIdAtom } from '@/store/business-atoms'`
  - Replace `import { saveScenario, saveActiveState } from '@/lib/firestore'` with `import { saveScenarioData, saveScenarioPreferences } from '@/lib/business-firestore'`
  - Change `const planId = useAtomValue(currentPlanIdAtom)` to `const businessId = useAtomValue(activeBusinessIdAtom)`
  - Guard the auto-save with `if (!businessId) return` — skip saving when no business selected
  - Replace `saveScenario(planId, scenario)` with `saveScenarioData(businessId, scenario)`
  - Replace `saveActiveState(planId, ...)` with `saveScenarioPreferences(businessId, ...)`

  **Step 2: Migrate `ScenarioSync` component in `providers.tsx`.**

  In `src/app/providers.tsx`:
  - Replace `import { currentPlanIdAtom } from '@/store/plan-atoms'` with `import { activeBusinessIdAtom } from '@/store/business-atoms'`
  - Replace `import { listScenarios, getActiveState, saveScenario, saveActiveState } from '@/lib/firestore'` with `import { listScenarioData, getScenarioPreferences, saveScenarioData, saveScenarioPreferences } from '@/lib/business-firestore'`
  - Change `const planId = useAtomValue(currentPlanIdAtom)` to `const businessId = useAtomValue(activeBusinessIdAtom)`
  - **Critical: Make ScenarioSync re-initialize when business changes.** The current `loadedRef` pattern prevents reloading. Change the approach:
    - Track `prevBusinessIdRef` to detect business changes
    - When `businessId` changes: reset `loadedRef.current = false`, reset `scenarioSyncReadyAtom` to `false`, clear `scenarioListAtom`
    - Guard the init with `if (!businessId) return` — skip when no business selected
  - Replace all old firestore calls with new business-scoped equivalents:
    - `listScenarios(planId)` → `listScenarioData(businessId)`
    - `getActiveState(planId)` → `getScenarioPreferences(businessId)`
    - `saveScenario(planId, baseline)` → `saveScenarioData(businessId, baseline)`
    - `saveActiveState(planId, ...)` → `saveScenarioPreferences(businessId, ...)`
  - Remove the `planId` variable and `currentPlanIdAtom` import entirely

  **Step 3: Migrate `ScenarioManager` component.**

  In `src/features/scenarios/scenario-manager.tsx`:
  - Replace `import { currentPlanIdAtom } from '@/store/plan-atoms'` with `import { activeBusinessIdAtom } from '@/store/business-atoms'`
  - Replace `import { listScenarios, deleteScenario, saveActiveState } from '@/lib/firestore.ts'` with `import { listScenarioData, deleteScenarioData, saveScenarioPreferences } from '@/lib/business-firestore'`
  - Change `const planId = useAtomValue(currentPlanIdAtom)` to `const businessId = useAtomValue(activeBusinessIdAtom)`
  - Guard handlers with early return if `!businessId`
  - Replace all old firestore calls:
    - `listScenarios(planId)` → `listScenarioData(businessId!)`
    - `saveActiveState(planId, ...)` → `saveScenarioPreferences(businessId!, ...)`
    - `deleteScenario(planId, currentId)` → `deleteScenarioData(businessId!, currentId)`

  **Step 4: Verify no remaining imports from deleted files.**
  Run grep to confirm zero imports from `@/store/plan-atoms` or `@/lib/firestore` remain in the codebase.
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no TypeScript errors. Run `grep -r "plan-atoms\|from '@/lib/firestore'" src/` to verify zero remaining imports of deleted files.</verify>
  <done>
  - `useScenarioSync` saves scenarios to `businesses/{businessId}/scenarios/` path
  - `ScenarioSync` provider loads/creates scenarios from business-scoped paths and re-initializes on business switch
  - `ScenarioManager` operates on business-scoped scenario paths
  - Zero imports remain from `@/store/plan-atoms` or `@/lib/firestore`
  - `npx tsc --noEmit` passes
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes with zero errors
- [ ] No imports from `@/store/plan-atoms` or `@/lib/firestore` exist in the codebase
- [ ] `src/store/plan-atoms.ts` and `src/lib/firestore.ts` are deleted
- [ ] `business-firestore.ts` exports section data + scenario data functions
- [ ] All hooks/providers reference `activeBusinessIdAtom` for business scoping
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Section data loads from `businesses/{businessId}/sections/{sectionKey}` path
- Scenario data loads from `businesses/{businessId}/scenarios/{scenarioId}` path
- Switching `activeBusinessIdAtom` causes scenario layer to reinitialize with new business data
- useSection reloads section data when business changes
  </success_criteria>

<output>
After completion, create `.planning/phases/03-dynamic-business-context/03-01-SUMMARY.md`
</output>
