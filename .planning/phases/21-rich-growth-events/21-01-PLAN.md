---
phase: 21-rich-growth-events
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/plan.ts
  - src/types/index.ts
  - src/features/sections/growth-timeline/compute.ts
  - src/features/sections/growth-timeline/compute.test.ts
autonomous: true
---

<objective>
Add 6 new growth event types with duration support to the type system and compute engine.

Purpose: Extend the growth timeline from 5 atomic event types to 11 business-relevant types covering funding, operations, team, revenue, and cost structure — each tied to real financial calculations.
Output: New delta interfaces in plan.ts, duration-aware compute logic in compute.ts, comprehensive tests in compute.test.ts.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-rich-growth-events/21-CONTEXT.md

@src/types/plan.ts
@src/types/index.ts
@src/features/sections/growth-timeline/compute.ts
@src/features/sections/growth-timeline/compute.test.ts
@src/features/sections/operations/compute.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add new delta interfaces and extend GrowthEvent type</name>
  <files>src/types/plan.ts, src/types/index.ts</files>
  <action>
In `src/types/plan.ts`, add 6 new delta interfaces after the existing delta interfaces (after CustomDelta):

1. `FundingRoundDelta` — `{ amount: number; legalCosts: number; investmentType: 'equity' | 'debt' | 'grant' }`
2. `FacilityBuildDelta` — `{ constructionCost: number; monthlyRent: number; capacityAdded: number; capacityItemId?: string }`
3. `HiringCampaignDelta` — `{ totalHires: number; role: string; ratePerHour: number; hoursPerWeek: number; recruitingCostPerHire: number }`
4. `PriceChangeDelta` — `{ newAvgCheck: number }`
5. `EquipmentPurchaseDelta` — `{ purchaseCost: number; capacityIncrease: number; maintenanceCostMonthly: number; capacityItemId?: string }`
6. `SeasonalCampaignDelta` — `{ budgetIncrease: number }`

Extend `GrowthEventType` union with 6 new string literals:
`'funding-round' | 'facility-build' | 'hiring-campaign' | 'price-change' | 'equipment-purchase' | 'seasonal-campaign'`

Extend `GrowthEventDelta` discriminated union with 6 new members:
```
| { type: 'funding-round'; data: FundingRoundDelta }
| { type: 'facility-build'; data: FacilityBuildDelta }
| { type: 'hiring-campaign'; data: HiringCampaignDelta }
| { type: 'price-change'; data: PriceChangeDelta }
| { type: 'equipment-purchase'; data: EquipmentPurchaseDelta }
| { type: 'seasonal-campaign'; data: SeasonalCampaignDelta }
```

Add `durationMonths?: number` to the `GrowthEvent` interface. This is used by duration-aware types (facility-build, hiring-campaign, seasonal-campaign). Undefined or 0 means instant event.

In `src/types/index.ts`, add exports for all 6 new delta interfaces.
  </action>
  <verify>npx tsc --noEmit passes</verify>
  <done>All 6 delta interfaces exported, GrowthEventType has 11 members, GrowthEventDelta has 11 union members, GrowthEvent has optional durationMonths</done>
</task>

<task type="auto">
  <name>Task 2: Implement new event types and duration logic in compute engine</name>
  <files>src/features/sections/growth-timeline/compute.ts</files>
  <action>
Extend the `computeGrowthTimeline` function's event processing loop. Currently it iterates month 1..horizonMonths and for each month applies all enabled events where `event.month <= currentMonth`.

The new types require three temporal patterns:

**Pattern A — One-time effect (applies only in event.month):**
Check `event.month === m` (not `<=`).
- `funding-round`: In the event month only: add `amount` to a `oneTimeRevenue` accumulator, add `legalCosts` to a `oneTimeFixedCost` accumulator. These one-time values are added to revenue/fixedCost for that month only.
- `equipment-purchase`: In the event month only: add `purchaseCost` to `oneTimeFixedCost`. Ongoing from event.month: add `maintenanceCostMonthly` to fixedCost accumulator, add `capacityIncrease` to capacity (same per-item or global logic as capacity-change).

**Pattern B — Duration event (active only during build period, effects after):**
Calculate: `startMonth = event.month`, `endMonth = event.month + (event.durationMonths || 1) - 1`, `completedMonth = endMonth + 1`.
- `facility-build`:
  - During (startMonth <= m <= endMonth): add `constructionCost / durationMonths` to fixedCost each month (spread evenly)
  - After (m >= completedMonth): add `monthlyRent` to fixedCost, add `capacityAdded` to capacity (same per-item or global logic as capacity-change, using `capacityItemId` if set)
- `hiring-campaign`:
  - During (startMonth <= m <= endMonth): calculate `hiresThisMonth = Math.floor(totalHires * (monthIndex + 1) / durationMonths) - Math.floor(totalHires * monthIndex / durationMonths)` where `monthIndex = m - startMonth`. For each cumulative hire so far (total hires up to month m), add a WorkforceMember. Also add `recruitingCostPerHire * hiresThisMonth` to fixedCost for that month only (one-time per hire).
  - After (m >= completedMonth): all `totalHires` are active workforce members (ongoing cost), no more recruiting costs.

Actually simplify hiring-campaign: track `cumulativeHires = Math.min(totalHires, Math.floor(totalHires * (m - startMonth + 1) / durationMonths))` for months during build. After completion: `cumulativeHires = totalHires`. Then add `cumulativeHires` workforce members. For recruiting cost: `newHiresThisMonth = cumulativeHires(m) - cumulativeHires(m-1)`, add `newHiresThisMonth * recruitingCostPerHire` as one-time fixedCost.

**Pattern C — Temporary effect (active during duration, reverts after):**
- `seasonal-campaign`:
  - During (startMonth <= m <= endMonth): add `budgetIncrease` to marketing budget
  - After (m > endMonth): no effect (reverts)

**Pattern D — Instant ongoing (from event.month forever):**
- `price-change`: Override `effectiveAvgCheck` from event.month onwards. Last writer wins (like marketing-change).

Implementation approach in the per-month loop:
1. Before the event loop, add `oneTimeRevenue = 0` and `oneTimeFixedCost = 0` accumulators (reset each month).
2. Inside the event switch, add cases for all 6 new types with the temporal logic above.
3. For `price-change`, add mutation of `effectiveAvgCheck` (currently hardcoded to `baseAvgCheck` — make it mutable, initialized to `baseAvgCheck` before the event loop for each month, then `price-change` events can override it).
4. When computing revenue: `revenue = seasonalBookings * effectiveAvgCheck + customRevenueDelta + oneTimeRevenue`
5. When computing fixedCost: `fixedCost = opsCosts.fixedMonthlyTotal + customFixedCostDelta + oneTimeFixedCost`

Important: for hiring-campaign workforce members, use the same pattern as the `hire` case — append WorkforceMember objects to `effectiveWorkforce`. The role, ratePerHour, hoursPerWeek come from the delta data. Count = cumulativeHires.

Important: for equipment-purchase and facility-build capacity changes, use the same per-item or global pattern as `capacity-change` — mutate `effectiveCapacityItems` array.

Do NOT restructure the existing event processing. Keep the same loop structure, just add new cases to the switch statement and the new accumulators.
  </action>
  <verify>npx tsc --noEmit passes</verify>
  <done>All 6 new event types handled in compute engine with correct temporal patterns (one-time, duration, temporary, instant-ongoing)</done>
</task>

<task type="auto">
  <name>Task 3: Write tests for all new event types and duration logic</name>
  <files>src/features/sections/growth-timeline/compute.test.ts</files>
  <action>
Add test cases to the existing test suite. Use the same test patterns already established (baseInput helper, describe blocks).

Tests to add:

**funding-round:**
1. "funding-round adds amount to revenue and legalCosts to fixedCost only in event month" — event at month 3 with amount=100000, legalCosts=5000. Month 3 revenue should include +100000, month 3 fixedCost should include +5000. Month 4 should NOT have these additions.

**facility-build:**
2. "facility-build spreads construction cost during build and adds rent+capacity after" — event at month 2, durationMonths=3, constructionCost=90000, monthlyRent=3000, capacityAdded=50. Months 2-4: fixedCost includes +30000/month (90000/3). Month 5+: fixedCost includes +3000 (rent), plannedOutput includes +50. Month 1: no effect.

**hiring-campaign:**
3. "hiring-campaign staggers hires over duration months" — event at month 1, durationMonths=4, totalHires=4, role='dev', ratePerHour=50, hoursPerWeek=40, recruitingCostPerHire=2000. Each month should add ~1 hire. By month 4, all 4 hires active. After month 4, 4 hires ongoing, no recruiting costs.

**price-change:**
4. "price-change overrides avgCheck from event month" — event at month 4, newAvgCheck=200. Months 1-3: revenue uses baseAvgCheck (100). Month 4+: revenue uses 200.

**equipment-purchase:**
5. "equipment-purchase has one-time cost plus ongoing maintenance and capacity" — event at month 3, purchaseCost=50000, capacityIncrease=20, maintenanceCostMonthly=500. Month 3: fixedCost includes +50000 (one-time) + 500 (maintenance). Month 4: fixedCost includes +500 only (no purchase cost). PlannedOutput increases by 20 from month 3.

**seasonal-campaign:**
6. "seasonal-campaign increases marketing budget only during duration" — event at month 3, durationMonths=3, budgetIncrease=5000. Months 3-5: marketing budget += 5000. Month 6+: marketing budget back to base. Months 1-2: no effect.

**Duration edge cases:**
7. "duration event with durationMonths=1 acts like instant event" — facility-build at month 5, durationMonths=1. Month 5: full construction cost as fixedCost. Month 6+: rent + capacity.
8. "duration event without durationMonths defaults to 1" — facility-build at month 5, no durationMonths set. Same behavior as durationMonths=1.

Keep all existing tests intact. Run `npx vitest run` to confirm all tests pass (existing + new).
  </action>
  <verify>npx vitest run — all tests pass (existing ~106 + 8 new = ~114)</verify>
  <done>8+ new test cases covering all 6 event types and duration edge cases, all passing alongside existing tests</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes — no type errors
- [ ] `npx vitest run` passes — all tests green (existing + new)
- [ ] `npx vite build` succeeds — no build errors
- [ ] All 6 new event types compute correctly with proper temporal patterns
</verification>

<success_criteria>

- All 6 new delta interfaces defined and exported
- GrowthEvent has durationMonths field
- Compute engine handles: one-time effects, duration spreading, temporary effects, instant-ongoing effects
- 8+ new tests covering all new types and duration edge cases
- All existing tests still pass (no regressions)
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/21-rich-growth-events/21-01-SUMMARY.md`
</output>
