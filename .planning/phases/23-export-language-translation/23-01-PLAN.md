---
phase: 23-export-language-translation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [functions/src/index.ts, src/lib/ai/translate-client.ts]
autonomous: true
---

<objective>
Add a Cloud Function endpoint for translating business plan text content and a client-side translation utility.

Purpose: Provide the AI translation infrastructure that the export UI will call before generating the PDF.
Output: `aiTranslateSection` Cloud Function + `translateSectionTexts()` client helper.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@functions/src/index.ts
@src/lib/ai/proxy-fetch.ts
@src/lib/ai/gemini-client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add aiTranslateSection Cloud Function endpoint</name>
  <files>functions/src/index.ts</files>
  <action>
Add a new `aiTranslateSection` endpoint following the exact same pattern as `aiGeminiGenerate` (auth, rate limiting, CORS, secrets).

Request body:
```ts
{
  texts: Record<string, string>,  // key → text to translate (e.g. { summary: "...", mission: "..." })
  targetLanguage: string,         // e.g. "Spanish", "French", "Russian"
}
```

Response: `{ translated: Record<string, string> }` — same keys, translated values.

Implementation:
- Use `responseMimeType: 'application/json'` with a `responseSchema` so Gemini returns structured JSON matching the input keys.
- Build a responseSchema dynamically from the input keys: `{ type: "object", properties: { [key]: { type: "string" } for each key }, required: [...keys] }`.
- System instruction: "You are a professional business plan translator. Translate the provided text fields into {targetLanguage}. Preserve all markdown formatting (bold, italic, links, lists). Preserve numbers, proper nouns, brand names, and technical terms. Return ONLY the translated text for each field."
- Prompt: serialize the texts as JSON for Gemini to translate.
- Use timeoutSeconds: 180 (translation of long texts may take longer than generation).
- Validate that `texts` is a non-empty object and `targetLanguage` is a non-empty string.
  </action>
  <verify>cd functions && npm run build — compiles without errors</verify>
  <done>New aiTranslateSection endpoint exists in functions/src/index.ts, follows same auth/rate-limit/CORS pattern as existing endpoints, builds successfully.</done>
</task>

<task type="auto">
  <name>Task 2: Create client-side translation utility</name>
  <files>src/lib/ai/translate-client.ts</files>
  <action>
Create a new file `src/lib/ai/translate-client.ts` that exports a helper function for translating section text content.

```ts
import { proxyFetch } from './proxy-fetch';

interface TranslateResponse {
  translated: Record<string, string>;
}

/**
 * Translate a batch of text fields via the AI proxy.
 * Keys are preserved; values are translated to targetLanguage.
 */
export async function translateTexts(
  texts: Record<string, string>,
  targetLanguage: string,
): Promise<Record<string, string>> {
  const { translated } = await proxyFetch<TranslateResponse>('aiTranslateSection', {
    texts,
    targetLanguage,
  });
  return translated;
}
```

This keeps the client simple — the Export component will extract text fields from section data, call this in batches, and merge results back.
  </action>
  <verify>npx vite build — compiles without errors</verify>
  <done>translate-client.ts exports translateTexts function, uses proxyFetch pattern, type-safe.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd functions && npm run build` succeeds
- [ ] `npx vite build` succeeds
- [ ] `npx vitest run` — existing tests pass
</verification>

<success_criteria>

- aiTranslateSection Cloud Function endpoint added with auth + rate limiting
- translateTexts client helper created
- All builds pass
</success_criteria>

<output>
After completion, create `.planning/phases/23-export-language-translation/23-01-SUMMARY.md`
</output>
