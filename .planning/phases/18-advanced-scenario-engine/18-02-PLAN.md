---
phase: 18-advanced-scenario-engine
plan: 02
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - src/lib/effective-plan.ts
  - src/store/scenario-atoms.ts
autonomous: true
---

<objective>
Create the effective plan composition layer that merges base section data + selected variant + section overrides into a single "effective" section view per scenario.

Purpose: Core engine that enables scenarios to modify section content, not just numeric variables.
Output: New effective-plan.ts module with merge functions + Jotai atoms for reactive effective section data.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/18-advanced-scenario-engine/18-01-PLAN.md

@src/types/scenario.ts
@src/types/plan.ts
@src/store/scenario-atoms.ts
@src/store/business-atoms.ts
@src/hooks/use-section.ts
@src/lib/business-firestore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create effective-plan.ts merge module</name>
  <files>src/lib/effective-plan.ts</files>
  <action>
Create `src/lib/effective-plan.ts` with the following functions:

**1. `deepMergeSection<T>(base: T, overlay: Partial<T>): T`**
- Deep merge of section data. Overlay fields replace base fields.
- Arrays: overlay replaces (not concatenates) — section arrays like offerings[], competitors[], etc. are always fully replaced by the overlay.
- Nested objects: recursive merge (one level deep only — Firestore's 2-level nesting limit).
- null/undefined in overlay: skip (don't delete base fields).

**2. `computeEffectiveSection<T>(base: T, variant: T | null, overrides: Partial<T> | null): T`**
- Start with `base`
- If `variant` is provided, use it as the new base (variant replaces the entire section)
- If `overrides` is provided, deep-merge overrides on top: `deepMergeSection(effective, overrides)`
- Return the effective section

**3. `resolveEffectivePlan(config: { baseSections: Record<string, unknown>, activeScenario: DynamicScenario, variants: Record<string, unknown> }): Record<string, unknown>`**
- For each section slug in baseSections:
  - Look up `activeScenario.variantRefs?.[slug]` → if present, use `variants[variantId]` as variant data
  - Look up `activeScenario.sectionOverrides?.[slug]` → if present, use as overrides
  - Call `computeEffectiveSection(base, variant, overrides)`
- Return the full effective plan as `Record<sectionSlug, effectiveSectionData>`

Keep these as pure functions (no side effects, no atoms, no Firestore) for easy testing. Import types from `@/types/scenario` and `@/types/plan`.
  </action>
  <verify>npm run build — passes. No TypeScript errors in effective-plan.ts.</verify>
  <done>Pure merge functions created. computeEffectiveSection handles base→variant→override composition chain.</done>
</task>

<task type="auto">
  <name>Task 2: Add effective section atoms to scenario store</name>
  <files>src/store/scenario-atoms.ts</files>
  <action>
Add new atoms to `src/store/scenario-atoms.ts` that expose v2 scenario fields reactively:

**1. `scenarioAssumptionsAtom`**: `atom<ScenarioAssumption[]>` — writable atom for the active scenario's assumptions. Default: `[]`.

**2. `scenarioVariantRefsAtom`**: `atom<Record<string, string>>` — writable atom for the active scenario's variantRefs. Default: `{}`.

**3. `scenarioSectionOverridesAtom`**: `atom<Record<string, Record<string, unknown>>>` — writable atom for the active scenario's sectionOverrides. Default: `{}`.

**4. `scenarioStatusAtom`**: `atom<ScenarioStatus>` — writable atom for scenario status. Default: `'draft'`.

**5. `scenarioHorizonAtom`**: `atom<number>` — writable atom for horizonMonths. Default: `12`.

Update `loadDynamicScenarioAtom` (existing write-only action atom) to also populate the new atoms when loading a scenario:
```typescript
// In the existing load action, after setting values/name/id:
set(scenarioAssumptionsAtom, scenario.assumptions ?? []);
set(scenarioVariantRefsAtom, scenario.variantRefs ?? {});
set(scenarioSectionOverridesAtom, scenario.sectionOverrides ?? {});
set(scenarioStatusAtom, scenario.status ?? 'draft');
set(scenarioHorizonAtom, scenario.horizonMonths ?? 12);
```

Update `resetDynamicToDefaultsAtom` to also reset v2 atoms to defaults.

Export all new atoms.
  </action>
  <verify>npm run build — passes. No TypeScript errors in scenario-atoms.ts.</verify>
  <done>V2 scenario atoms created and integrated with load/reset actions. Reactive state available for UI consumption.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds
- [ ] `npm run lint` passes
- [ ] effective-plan.ts exports pure merge functions
- [ ] scenario-atoms.ts exports new v2 atoms
- [ ] loadDynamicScenarioAtom populates v2 atoms from scenario data
</verification>

<success_criteria>
- deepMergeSection handles nested objects and array replacement
- computeEffectiveSection chains base→variant→override correctly
- All v2 atoms are reactive (read/write) and integrated with load/reset
- No breaking changes to existing scenario controls or sync
</success_criteria>

<output>
After completion, create `.planning/phases/18-advanced-scenario-engine/18-02-SUMMARY.md`
</output>
