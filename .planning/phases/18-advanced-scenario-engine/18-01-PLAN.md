---
phase: 18-advanced-scenario-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/scenario.ts
  - src/lib/business-firestore.ts
autonomous: true
---

<objective>
Extend DynamicScenario with v2 fields (assumptions, variantRefs, sectionOverrides, status, horizonMonths) and update Firestore persistence. Old scenarios (values-only) must continue to load without migration.

Purpose: Foundation types and persistence for the entire Advanced Scenario Engine phase.
Output: Updated DynamicScenario type, normalizeScenario function, updated Firestore functions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/types/scenario.ts
@src/types/plan.ts
@src/lib/business-firestore.ts
@src/features/sections/product-service/normalize.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend DynamicScenario types with v2 fields</name>
  <files>src/types/scenario.ts</files>
  <action>
Add the following types and update DynamicScenario in `src/types/scenario.ts`:

```typescript
export interface ScenarioAssumption {
  id: string;
  label: string;
  value: string;
  category?: string;
}

export type ScenarioStatus = 'draft' | 'active' | 'archived';

// variantRefs maps section slug to variant document ID
// sectionOverrides maps section slug to partial section data
```

Update `DynamicScenario` to add v2 fields — ALL optional for backward compatibility:

```typescript
export interface DynamicScenario {
  metadata: ScenarioMetadata;
  values: Record<string, number>;

  // v2 fields (all optional — old scenarios omit these)
  assumptions?: ScenarioAssumption[];
  variantRefs?: Record<string, string>;       // sectionSlug -> variantId
  sectionOverrides?: Record<string, Record<string, unknown>>; // sectionSlug -> partial data
  status?: ScenarioStatus;
  horizonMonths?: number;
}
```

Create a `normalizeScenario` function (following the normalizeProductService pattern from Plan 17-01):

```typescript
export function normalizeScenario(data: unknown): DynamicScenario {
  // Handle null/undefined → empty scenario with new UUID
  // Handle old format (values-only, no v2 fields) → add defaults
  // Handle new format → passthrough
  // Defaults: assumptions=[], variantRefs={}, sectionOverrides={}, status='draft', horizonMonths=12
}
```

Export all new types from `src/types/index.ts` barrel.
  </action>
  <verify>npm run build — no TypeScript errors in scenario.ts or index.ts</verify>
  <done>DynamicScenario has v2 fields, normalizeScenario handles old data, all types exported.</done>
</task>

<task type="auto">
  <name>Task 2: Update Firestore persistence for v2 scenario fields</name>
  <files>src/lib/business-firestore.ts</files>
  <action>
Update `saveScenarioData` to persist all v2 fields. Since Firestore uses `merge: true`, old documents will simply gain new fields on next save.

Update `getScenarioData` to normalize loaded data through `normalizeScenario` before returning. This ensures old scenarios get default v2 field values.

Update `listScenarioData` to normalize each scenario through `normalizeScenario`.

Add new Firestore functions for section variants (stored as subcollection of the section document):

```typescript
// Path: businesses/{businessId}/sections/{sectionSlug}/variants/{variantId}
export interface SectionVariant {
  id: string;
  name: string;
  description?: string;
  data: Record<string, unknown>;  // the full or partial section data snapshot
  createdAt: string;
  scenarioId?: string;  // which scenario created this variant (optional reference)
}

export async function saveSectionVariant(businessId: string, sectionSlug: string, variant: SectionVariant): Promise<void>
export async function getSectionVariant(businessId: string, sectionSlug: string, variantId: string): Promise<SectionVariant | null>
export async function listSectionVariants(businessId: string, sectionSlug: string): Promise<SectionVariant[]>
export async function deleteSectionVariant(businessId: string, sectionSlug: string, variantId: string): Promise<void>
```

Firestore path for variants: `businesses/{businessId}/sections/{sectionSlug}/variants/{variantId}`

Use the same error handling pattern as existing functions (try/catch with logger). Wrap writes in `withRetry` from `@/lib/sync-status` (same pattern as other Firestore operations in this file).
  </action>
  <verify>npm run build — passes. No TypeScript errors in business-firestore.ts.</verify>
  <done>Firestore layer saves/loads v2 scenario fields. Old scenarios load with defaults. Section variant CRUD functions exist.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds
- [ ] `npm run lint` passes (or only pre-existing warnings)
- [ ] Old DynamicScenario data (values-only) normalizes correctly with default v2 fields
- [ ] New types are exported from barrel
</verification>

<success_criteria>
- DynamicScenario v2 type defined with all new fields (optional for backward compat)
- normalizeScenario function handles old and new formats
- Firestore save/load/list use normalizeScenario
- SectionVariant CRUD functions implemented
- No breaking changes to existing scenario functionality
</success_criteria>

<output>
After completion, create `.planning/phases/18-advanced-scenario-engine/18-01-SUMMARY.md`
</output>
