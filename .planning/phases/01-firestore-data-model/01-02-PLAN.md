---
phase: 01-firestore-data-model
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified: [src/lib/business-firestore.ts, firestore.rules]
autonomous: true
---

<objective>
Implement the Firestore service layer for multi-business operations and security rules.

Purpose: Create the data access functions that all subsequent phases use to interact with Firestore — business CRUD, template reading, business-scoped sections/scenarios, and template-based business creation. Also establish proper Firestore security rules for multi-tenant access.

Output: `src/lib/business-firestore.ts` with all business-related Firestore operations, updated `firestore.rules` with role-based access control.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-firestore-data-model/01-RESEARCH.md
@.planning/phases/01-firestore-data-model/01-CONTEXT.md
@.planning/phases/01-firestore-data-model/01-01-SUMMARY.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/ARCHITECTURE.md

@src/types/business.ts
@src/lib/firebase.ts
@src/lib/firestore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create business Firestore service layer</name>
  <files>src/lib/business-firestore.ts</files>
  <action>
Create `src/lib/business-firestore.ts` with all multi-business Firestore operations. Follow the existing pattern from `src/lib/firestore.ts`: import from `firebase/firestore`, import `db` from `./firebase.ts`, use typed functions.

**Business CRUD functions:**

```typescript
// Create a new business document
async function createBusiness(business: Omit<Business, 'id'>): Promise<string>
// - Use addDoc or doc(collection(...)) to auto-generate ID
// - Return the generated business ID

// Get a single business by ID
async function getBusiness(businessId: string): Promise<Business | null>

// Update business fields (partial update)
async function updateBusiness(businessId: string, data: Partial<Business>): Promise<void>
// - Use setDoc with merge: true
// - Auto-set updatedAt to new Date().toISOString()

// Delete business and all subcollections
async function deleteBusiness(businessId: string): Promise<void>
// - Delete business document
// - NOTE: Firestore doesn't cascade-delete subcollections; add comment noting
//   sections/scenarios must be deleted separately (or via Cloud Function later)

// Get all businesses where user has a role
async function getUserBusinesses(uid: string): Promise<Business[]>
// - Use where(`roles.${uid}`, '!=', null) query
// - Return array sorted by updatedAt descending
```

**Template functions:**

```typescript
// Get a single template
async function getTemplate(templateId: string): Promise<BusinessTemplate | null>

// List all available templates
async function listTemplates(): Promise<BusinessTemplate[]>
// - Query templates collection, return all documents
// - Sort by name
```

**Business creation from template (batch write):**

```typescript
// Create a new business from a template
async function createBusinessFromTemplate(
  templateId: string,
  userId: string,
  businessName: string,
  profile: Partial<BusinessProfile>
): Promise<string>
// 1. Read template document
// 2. Create writeBatch
// 3. Create business document with:
//    - Auto-generated ID
//    - ownerId: userId
//    - templateId, templateVersion from template
//    - roles: { [userId]: 'owner' }
//    - enabledSections: Object.keys(template.sections)
//    - profile merged with template defaults
//    - createdAt, updatedAt timestamps
// 4. Create section documents from template.sections:
//    - Path: businesses/{businessId}/sections/{sectionKey}
//    - Copy: sectionKey, label, order, schema, data from template defaultData
// 5. Create default scenario from template.defaultVariables:
//    - Path: businesses/{businessId}/scenarios/{auto-id}
//    - name: 'Base Case', isDefault: true
//    - variables: template.defaultVariables
// 6. Commit batch
// 7. Return business ID
//
// IMPORTANT: Use writeBatch (not runTransaction) — we're only writing new docs.
// Count operations before commit (max 500 per batch).
```

**Business-scoped section functions:**

```typescript
// Get a section from a business
async function getBusinessSection(businessId: string, sectionKey: string): Promise<BusinessSection | null>

// Save a section to a business (merge)
async function saveBusinessSection(businessId: string, sectionKey: string, data: Partial<BusinessSection>): Promise<void>

// List all sections for a business
async function listBusinessSections(businessId: string): Promise<BusinessSection[]>
```

**Business-scoped scenario functions:**

```typescript
// Get a scenario from a business
async function getBusinessScenario(businessId: string, scenarioId: string): Promise<BusinessScenario | null>

// Save a scenario to a business
async function saveBusinessScenario(businessId: string, scenario: BusinessScenario): Promise<void>

// List all scenarios for a business
async function listBusinessScenarios(businessId: string): Promise<BusinessScenario[]>

// Delete a scenario from a business
async function deleteBusinessScenario(businessId: string, scenarioId: string): Promise<void>
```

**Share/invite functions:**

```typescript
// Add a user role to a business
async function addBusinessRole(businessId: string, uid: string, role: BusinessRole): Promise<void>
// - Use updateDoc with dot notation: `roles.${uid}` = role

// Remove a user role from a business
async function removeBusinessRole(businessId: string, uid: string): Promise<void>
// - Use updateDoc with deleteField(): `roles.${uid}` = deleteField()
```

**Conventions to follow:**
- Named exports (no default exports)
- Import types from `@/types`
- Import `db` from `./firebase.ts`
- Use Firestore modular SDK (`doc`, `collection`, `getDocs`, `setDoc`, etc.)
- Inline Firestore path comments: `// Firestore path: businesses/{businessId}/sections/{sectionKey}`
- DO NOT touch existing `src/lib/firestore.ts` — it continues working for current `plans/` paths until Phase 3
  </action>
  <verify>npx tsc --noEmit passes with no errors</verify>
  <done>All business Firestore functions compile, are exported, and follow project conventions. Functions cover: business CRUD, template reading, template-based creation, business-scoped sections/scenarios, role management.</done>
</task>

<task type="auto">
  <name>Task 2: Create Firestore security rules for multi-business access</name>
  <files>firestore.rules</files>
  <action>
Replace the current permissive `firestore.rules` with proper role-based security rules for the multi-business data model.

**Rules structure:**

```javascript
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- Templates: read-only for authenticated users ---
    match /templates/{templateId} {
      allow read: if request.auth != null;
      allow write: if false;  // Admin-only via Firebase Admin SDK
    }

    // --- Businesses: role-based access via roles map ---
    match /businesses/{businessId} {

      // Helper: check if user has one of the specified roles
      function hasRole(roles) {
        return request.auth != null
          && request.auth.uid in resource.data.roles
          && resource.data.roles[request.auth.uid] in roles;
      }

      // Any authenticated user can create a business (they become owner)
      allow create: if request.auth != null
        && request.resource.data.roles[request.auth.uid] == 'owner';

      // Owner and editor can read
      allow read: if hasRole(['owner', 'editor']);

      // Owner and editor can update
      allow update: if hasRole(['owner', 'editor']);

      // Only owner can delete
      allow delete: if hasRole(['owner']);

      // --- Sections: inherit access from parent business ---
      match /sections/{sectionKey} {
        allow read: if get(/databases/$(database)/documents/businesses/$(businessId))
                       .data.roles[request.auth.uid] in ['owner', 'editor'];
        allow write: if get(/databases/$(database)/documents/businesses/$(businessId))
                        .data.roles[request.auth.uid] in ['owner', 'editor'];
      }

      // --- Scenarios: inherit access from parent business ---
      match /scenarios/{scenarioId} {
        allow read: if get(/databases/$(database)/documents/businesses/$(businessId))
                       .data.roles[request.auth.uid] in ['owner', 'editor'];
        allow write: if get(/databases/$(database)/documents/businesses/$(businessId))
                        .data.roles[request.auth.uid] in ['owner', 'editor'];
      }

      // --- Business state/preferences ---
      match /state/{stateDoc} {
        allow read: if get(/databases/$(database)/documents/businesses/$(businessId))
                       .data.roles[request.auth.uid] in ['owner', 'editor'];
        allow write: if get(/databases/$(database)/documents/businesses/$(businessId))
                        .data.roles[request.auth.uid] in ['owner', 'editor'];
      }
    }

    // --- Users: own profile only ---
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // --- Invites: owner creates, invited user reads/accepts ---
    match /invites/{inviteId} {
      // Anyone authenticated can read an invite (they need the token/ID to find it)
      allow read: if request.auth != null;

      // Only business owner can create invites
      // (validated by checking the business document's roles)
      allow create: if request.auth != null;

      // Update for acceptance (by the invited user)
      allow update: if request.auth != null;

      // Only creator can delete/revoke
      allow delete: if request.auth != null
        && resource.data.createdBy == request.auth.uid;
    }

    // --- Legacy: keep existing plans path working until Phase 3 migration ---
    match /plans/{planId}/{document=**} {
      allow read, write: if request.auth != null;
    }
  }
}
```

**IMPORTANT:**
- Keep the legacy `plans/{planId}` rule at the bottom so the existing app continues working
- The `get()` calls in subcollection rules each count toward the 10-call limit per read — this is fine since we only do 1 `get()` per subcollection access
- The `hasRole()` function avoids `get()` calls by reading directly from `resource.data` (the current document being accessed)
- For subcollections, we MUST use `get()` because the roles live on the parent business document, not on the subcollection document
  </action>
  <verify>Review rules file for syntax correctness. Verify legacy plans path is preserved.</verify>
  <done>Security rules cover all collections (templates, businesses, sections, scenarios, state, users, invites). Legacy plans path preserved. Role-based access enforced.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes with zero errors
- [ ] `src/lib/business-firestore.ts` exports all functions
- [ ] `firestore.rules` has valid syntax
- [ ] Legacy `plans/` path still works in rules
- [ ] Business CRUD functions use proper Firestore paths
- [ ] Template-based business creation uses `writeBatch`
- [ ] No modifications to existing `src/lib/firestore.ts`
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Service layer covers: business CRUD, template reading, template-based creation, business-scoped sections/scenarios, role management
- Security rules enforce: templates read-only, businesses role-based, subcollections inherit from parent, users own-profile-only
- Existing app functionality not broken (legacy plans path preserved)
  </success_criteria>

<output>
After completion, create `.planning/phases/01-firestore-data-model/01-02-SUMMARY.md`
</output>
