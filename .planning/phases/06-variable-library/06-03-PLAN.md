---
phase: 06-variable-library
plan: 03
type: execute
wave: 2
depends_on: ["06-02"]
files_modified:
  - src/lib/business-firestore.ts
  - src/hooks/use-business-variables.ts
  - src/store/business-atoms.ts
  - src/hooks/use-businesses.ts
  - src/app/providers.tsx
autonomous: true
---

<objective>
Add Firestore persistence for business variable definitions and auto-populate variables when creating a new business.

Purpose: When a user creates a SaaS business, it should immediately have MRR, churn, CAC, and all other SaaS-specific variables stored and ready to use. Variables persist across sessions and are editable.

Output: Firestore functions for variable CRUD, a useBusinessVariables hook for reading/writing, auto-population on business creation, and variable loading on business switch.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/06-variable-library/06-RESEARCH.md
@.planning/phases/06-variable-library/06-CONTEXT.md
@.planning/phases/06-variable-library/06-02-SUMMARY.md

@src/lib/business-firestore.ts
@src/hooks/use-businesses.ts
@src/store/business-atoms.ts
@src/app/providers.tsx
@src/lib/business-templates.ts
@src/lib/variable-templates/index.ts
@src/types/business.ts
</context>

<tasks>
<task type="auto">
  <name>Task 1: Add variable Firestore functions and create useBusinessVariables hook</name>
  <files>
    src/lib/business-firestore.ts
    src/hooks/use-business-variables.ts
    src/store/business-atoms.ts
  </files>
  <action>
    **1. Add Firestore functions to `src/lib/business-firestore.ts`:**

    Add two new functions for storing/retrieving business variable definitions. Variables are stored at `businesses/{businessId}/state/variables` (consistent with the existing `businesses/{businessId}/state/preferences` pattern).

    **`getBusinessVariables(businessId: string): Promise<Record<string, VariableDefinition> | null>`**
    - Get doc at `businesses/${businessId}/state/variables`
    - If exists, return `doc.data() as Record<string, VariableDefinition>` — BUT Firestore stores the variables as fields on the document, so the actual data shape is the whole document's data as Record<string, VariableDefinition>
    - Actually, better approach: store the variables Record as a single field on the document. The document at `state/variables` has one field: `definitions: Record<string, VariableDefinition>`. This avoids Firestore trying to flatten individual variable objects into document fields.
    - So: `const snap = await getDoc(doc(db, 'businesses', businessId, 'state', 'variables'))` → `snap.data()?.definitions ?? null`
    - If doc doesn't exist, return null
    - Import `VariableDefinition` from `@/types`

    **`saveBusinessVariables(businessId: string, variables: Record<string, VariableDefinition>): Promise<void>`**
    - `setDoc(doc(db, 'businesses', businessId, 'state', 'variables'), { definitions: variables }, { merge: true })`
    - This saves the full variable set as one atomic operation

    **2. Add Jotai atom to `src/store/business-atoms.ts`:**

    Add a new atom for the active business's variables:
    ```
    export const businessVariablesAtom = atom<Record<string, VariableDefinition> | null>(null);
    export const businessVariablesLoadedAtom = atom<boolean>(false);
    ```
    Import `VariableDefinition` from `@/types`.

    **3. Create `src/hooks/use-business-variables.ts`:**

    Hook that provides read/write access to the active business's variable definitions:

    ```typescript
    export function useBusinessVariables() {
      const businessId = useAtomValue(activeBusinessIdAtom);
      const variables = useAtomValue(businessVariablesAtom);
      const isLoaded = useAtomValue(businessVariablesLoadedAtom);
      const setVariables = useSetAtom(businessVariablesAtom);
      const setLoaded = useSetAtom(businessVariablesLoadedAtom);

      // Load variables from Firestore
      async function loadVariables() { ... }

      // Save all variables to Firestore (called after mutations)
      async function saveVariables(vars: Record<string, VariableDefinition>) { ... }

      // Update a single variable's value (for input variables)
      function updateVariableValue(variableId: string, newValue: number) {
        if (!variables) return;
        const updated = {
          ...variables,
          [variableId]: { ...variables[variableId], value: newValue },
        };
        setVariables(updated);
        // Fire-and-forget save to Firestore
        if (businessId) {
          saveBusinessVariables(businessId, updated).catch(console.error);
        }
      }

      // Add a new variable
      function addVariable(variable: VariableDefinition) { ... }

      // Remove a variable (and clean up references in other formulas' dependsOn)
      function removeVariable(variableId: string) { ... }

      // Update a variable's definition (label, formula, category, etc.)
      function updateVariableDefinition(variableId: string, updates: Partial<VariableDefinition>) { ... }

      return { variables, isLoaded, loadVariables, updateVariableValue, addVariable, removeVariable, updateVariableDefinition };
    }
    ```

    Each mutation does an optimistic local update (setVariables) then fire-and-forget Firestore save. Same pattern as useBusinesses.updateProfile.

    Import `getBusinessVariables`, `saveBusinessVariables` from `@/lib/business-firestore`.
    Import atoms from `@/store/business-atoms`.
  </action>
  <verify>Run `npx tsc --noEmit` — no TypeScript errors. The hook exports all methods. Firestore functions are correctly added.</verify>
  <done>
    - getBusinessVariables and saveBusinessVariables added to business-firestore.ts
    - businessVariablesAtom and businessVariablesLoadedAtom added to business-atoms.ts
    - useBusinessVariables hook created with load, save, update, add, remove operations
    - All optimistic updates + background persistence
    - No TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Auto-populate variables on business creation and load on business switch</name>
  <files>
    src/hooks/use-businesses.ts
    src/app/providers.tsx
  </files>
  <action>
    **1. Update `createNewBusiness` in `src/hooks/use-businesses.ts`:**

    After creating the business document in Firestore, also save the default variables:

    - Import `getDefaultVariables` from `@/lib/variable-templates`
    - Import `saveBusinessVariables` from `@/lib/business-firestore`
    - After `const businessId = await createBusiness({...})`, add:
      ```
      // Auto-populate variables from business type template
      const defaultVars = getDefaultVariables(type);
      await saveBusinessVariables(businessId, defaultVars);
      ```
    - This happens BEFORE the list refresh, so variables are ready when the user navigates to the new business

    **2. Add variable loading to `src/app/providers.tsx`:**

    Create a new `VariableLoader` component (similar to `BusinessLoader` and `ScenarioSync`):

    ```typescript
    function VariableLoader() {
      const authStatus = useAtomValue(authStatusAtom);
      const businessId = useAtomValue(activeBusinessIdAtom);
      const setVariables = useSetAtom(businessVariablesAtom);
      const setLoaded = useSetAtom(businessVariablesLoadedAtom);
      const prevBusinessIdRef = useRef<string | null>(null);

      useEffect(() => {
        // Reset on business change
        if (prevBusinessIdRef.current !== businessId) {
          if (prevBusinessIdRef.current !== null) {
            setVariables(null);
            setLoaded(false);
          }
          prevBusinessIdRef.current = businessId;
        }

        if (authStatus !== 'authenticated' || !businessId) return;

        async function init() {
          try {
            const vars = await getBusinessVariables(businessId!);
            setVariables(vars);
          } catch {
            // Silent fail — variables may not exist yet
          } finally {
            setLoaded(true);
          }
        }
        init();
      }, [authStatus, businessId, setVariables, setLoaded]);

      return null;
    }
    ```

    - Import `businessVariablesAtom`, `businessVariablesLoadedAtom` from `@/store/business-atoms`
    - Import `getBusinessVariables` from `@/lib/business-firestore`
    - Place `<VariableLoader />` in the Providers component tree, after `<BusinessLoader />` and before `<ScenarioSync />`:
      ```
      <BusinessLoader />
      <VariableLoader />
      <ScenarioSync />
      ```

    **Important:** Do NOT modify the existing ScenarioSync or hardcoded scenario system. Phase 7 will handle migration. VariableLoader operates independently.
  </action>
  <verify>Run `npx tsc --noEmit` — no TypeScript errors. Check that VariableLoader is rendered in Providers. Check that createNewBusiness calls saveBusinessVariables.</verify>
  <done>
    - createNewBusiness populates default variables from template on business creation
    - VariableLoader loads variables on auth + business switch
    - Variables reset correctly when switching businesses
    - No modifications to existing ScenarioSync
    - No TypeScript errors
  </done>
</task>
</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` succeeds
- [ ] createNewBusiness saves template variables to Firestore
- [ ] VariableLoader reads variables on business switch
- [ ] useBusinessVariables hook provides full CRUD
- [ ] Existing scenario system unchanged
- [ ] No regressions in existing build
</verification>

<success_criteria>
- Creating a new SaaS business auto-populates ~21 SaaS-specific variables
- Variables persist in Firestore at businesses/{id}/state/variables
- Switching businesses loads the correct variable set
- Hook provides optimistic updates with background persistence
- Existing hardcoded scenario system continues to work unchanged
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/06-variable-library/06-03-SUMMARY.md`
</output>
