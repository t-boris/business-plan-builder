---
phase: 03-what-if-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/features/scenarios/index.tsx, src/features/scenarios/scenario-controls.tsx, src/features/scenarios/scenario-dashboard.tsx, src/features/scenarios/scenario-manager.tsx, src/store/scenario-atoms.ts, src/store/derived-atoms.ts, src/lib/firestore.ts, src/types/scenario.ts]
autonomous: true
---

<objective>
Build the what-if scenario engine with interactive variable controls, real-time derived metric dashboard, and scenario CRUD (create, save, load, delete) with Firestore persistence.

Purpose: This is the core value of the app — changing any business variable and seeing how it ripples through all metrics in real time. Users can save different scenarios and switch between them.
Output: Working Scenarios page with variable sliders/inputs, live computed metrics, and save/load functionality.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Key source files:
@src/store/scenario-atoms.ts
@src/store/derived-atoms.ts
@src/lib/firestore.ts
@src/lib/constants.ts
@src/types/scenario.ts
@src/features/scenarios/index.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build scenario variable controls with real-time derived metrics dashboard</name>
  <files>src/features/scenarios/index.tsx, src/features/scenarios/scenario-controls.tsx, src/features/scenarios/scenario-dashboard.tsx</files>
  <action>
  1. Create `src/features/scenarios/scenario-controls.tsx` — the input panel for all scenario variables:
     - Read/write Jotai scenario atoms directly using `useAtom()` from jotai
     - Group controls into sections with Cards:

     **Pricing:**
     - Ocean Starter price: number Input with $ prefix (drives `priceStarterAtom`)
     - Ocean Explorer price: number Input with $ prefix (drives `priceExplorerAtom`)
     - Ocean VIP price: number Input with $ prefix (drives `priceVIPAtom`)

     **Leads & Conversion:**
     - Monthly Leads: number Input + range slider (drives `monthlyLeadsAtom`, range 50-300)
     - Conversion Rate: number Input as % + range slider (drives `conversionRateAtom`, range 5%-50%, store as 0.05-0.50)
     - CAC per Lead: number Input with $ + range slider (drives `cacPerLeadAtom`, range $5-$100)

     **Marketing Budgets:**
     - Meta Ads monthly budget: number Input with $ (drives `monthlyAdBudgetMetaAtom`)
     - Google Ads monthly budget: number Input with $ (drives `monthlyAdBudgetGoogleAtom`)

     **Operations:**
     - Crew Count: number Input (drives `crewCountAtom`, range 1-10)
     - Cost per Event: number Input with $ (drives `costPerEventAtom`)

     For sliders: use HTML `<input type="range">` styled with Tailwind (or install shadcn/ui slider: `npx shadcn@latest add slider`). Each variable has BOTH a number input and a slider, kept in sync.

     When any input changes, the Jotai atom updates immediately, and all derived atoms recompute automatically — this IS the real-time propagation.

  2. Create `src/features/scenarios/scenario-dashboard.tsx` — derived metrics display:
     - Read all derived atoms using `useAtomValue()`:
       - Monthly Bookings (from `monthlyBookingsAtom`)
       - Average Check (from `avgCheckAtom`)
       - Monthly Revenue (from `monthlyRevenueAtom`)
       - Monthly Costs (from `monthlyCostsAtom`)
       - Monthly Profit (from `monthlyProfitAtom`)
       - Profit Margin (from `profitMarginAtom`)
       - Annual Revenue (from `annualRevenueAtom`)
       - Annual Profit (from `annualProfitAtom`)
       - Total Ad Spend (from `totalMonthlyAdSpendAtom`)
       - CAC per Booking (from `cacPerBookingAtom`)
     - Display as a grid of stat cards (3-4 columns):
       - Each card: label, large formatted value (currency or percentage), optional trend indicator
       - Color code: revenue/profit green, costs orange, margin green if >20% amber if 10-20% red if <10%
     - Add a mini AreaChart (Recharts) showing 12-month projected revenue based on current scenario variables:
       - Simple projection: each month uses current monthlyRevenue derived value (flat line showing annualized)
       - OR: ramp pattern from current bookings assumption (more realistic)

  3. Replace `src/features/scenarios/index.tsx` — the main Scenarios page:
     - Two-column layout: controls on the left (40%), dashboard on the right (60%)
     - On mobile: stacked (controls on top, dashboard below)
     - Heading: "What-If Scenarios" with current scenario name displayed
     - Scenario name editable (Input at top, drives `scenarioNameAtom`)
     - Include a placeholder area at bottom for "Scenario Manager" (save/load) — will be built in Task 2

  **The key insight:** Changing any input immediately updates all derived atoms via Jotai's dependency graph. No manual useEffect, no recalculation functions — Jotai handles it all. This is why we chose Jotai.

  **Do NOT** connect to Firestore in this task — just Jotai atoms in memory. Persistence comes in Task 2.
  **Use `useAtom`** for writable atoms (controls), `useAtomValue` for read-only derived atoms (dashboard).
  </action>
  <verify>npm run build succeeds. Scenarios page shows controls and dashboard. Changing a price input instantly updates revenue/profit metrics.</verify>
  <done>Variable controls update Jotai atoms, derived metrics recompute in real-time, dashboard displays formatted stats with color coding</done>
</task>

<task type="auto">
  <name>Task 2: Build scenario CRUD with Firestore persistence</name>
  <files>src/features/scenarios/scenario-manager.tsx, src/store/scenario-atoms.ts, src/lib/firestore.ts, src/features/scenarios/index.tsx</files>
  <action>
  1. Update `src/store/scenario-atoms.ts` — add scenario management atoms:
     - `currentScenarioIdAtom` — atom storing the active scenario ID (default: 'baseline')
     - `scenarioListAtom` — atom storing array of ScenarioMetadata (loaded from Firestore)
     - `loadScenarioAtom` — writable atom that accepts a Scenario object and sets all primitive atoms to its variable values
     - `snapshotScenarioAtom` — read-only atom that reads all current primitive atoms and returns a ScenarioVariables object (for saving)

  2. Create `src/features/scenarios/scenario-manager.tsx` — scenario save/load UI:
     - **Save button:** Reads current scenario atom values via `snapshotScenarioAtom`, creates a Scenario object with metadata (name from `scenarioNameAtom`, current timestamp, generated ID), saves to Firestore via `saveScenario()`, updates `scenarioListAtom`
     - **Load scenario list:** On mount, call `listScenarios(planId)` from Firestore, display as a Select dropdown or list of cards
     - **Scenario switcher:** Select/dropdown showing all saved scenarios. Selecting one calls `loadScenarioAtom` to set all primitive atoms to the saved values
     - **New Scenario button:** Resets all atoms to defaults (from DEFAULT_SCENARIO_VARIABLES), sets a new name "New Scenario", generates new ID
     - **Delete button:** Removes scenario from Firestore, updates list. Cannot delete if it's the only scenario.
     - **Baseline indicator:** Show a badge if current scenario `isBaseline === true`

  3. Integrate scenario-manager into the Scenarios page:
     - Add ScenarioManager component at the top of the page (above the controls/dashboard split)
     - Show current scenario name, save button, scenario switcher, new/delete buttons
     - Layout: horizontal bar with scenario name, save, switch, new, delete — compact

  4. Update `src/lib/firestore.ts` if needed — ensure `saveScenario` and `listScenarios` work with the current atom structure. Add `deleteScenario(planId, scenarioId)` function.

  **Loading a scenario:** When user selects a saved scenario, ALL primitive atoms update → ALL derived atoms recompute → dashboard updates instantly. This is the Jotai magic.

  **Error handling:** If Firestore is not available (no emulator, no production), scenario manager should gracefully degrade — just use in-memory atoms without persistence, show a subtle "Offline mode" indicator.

  **Do NOT** auto-save scenarios on every variable change — only save when user clicks "Save". The real-time propagation is in-memory only.
  </action>
  <verify>npm run build succeeds. Can create a new scenario, change variables, save it, create another, switch between them — values update correctly.</verify>
  <done>Scenario CRUD works — save, load, switch, delete scenarios. Loading a scenario updates all variable atoms and derived metrics instantly. Firestore persistence with offline fallback.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds
- [ ] Scenarios page shows variable controls (pricing, leads, marketing, operations)
- [ ] Changing any variable immediately updates derived metrics (revenue, profit, margin)
- [ ] Sliders and number inputs stay in sync
- [ ] Can save a scenario with a name
- [ ] Can load a saved scenario — all values update
- [ ] Can create a new scenario (resets to defaults)
- [ ] Can delete a scenario
- [ ] Dashboard metrics are color-coded correctly
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Real-time propagation works (change input → derived metrics update instantly)
- Scenario CRUD works with Firestore persistence
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-what-if-engine/03-01-SUMMARY.md`
</output>
