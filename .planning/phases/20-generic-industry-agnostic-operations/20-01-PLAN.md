---
phase: 20-generic-industry-agnostic-operations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/types/plan.ts, src/types/index.ts, src/features/sections/operations/normalize.ts, src/features/sections/operations/compute.ts]
autonomous: true
---

<objective>
Define the new generic Operations data model and create normalization (migration) + cost computation functions.

Purpose: Replace event-specific Operations types with industry-agnostic model. Provide backward-compatible migration from old CostBreakdown data. Provide pure computation functions for cost summaries.
Output: New Operations types, normalizeOperations function, computeOperationsCosts function.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-generic-industry-agnostic-operations/20-CONTEXT.md

@src/types/plan.ts
@src/types/index.ts
@src/features/sections/product-service/normalize.ts
@src/features/sections/operations/index.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define new generic Operations types in plan.ts</name>
  <files>src/types/plan.ts, src/types/index.ts</files>
  <action>
  Replace the old Operations-related types (`CrewMember`, `CostBreakdown`, `Operations`) in `plan.ts` with the new generic model:

  ```ts
  export interface WorkforceMember {
    role: string;
    count: number;
    ratePerHour: number;
  }

  export interface CapacityConfig {
    outputUnitLabel: string;
    plannedOutputPerMonth: number;
    maxOutputPerDay: number;
    maxOutputPerWeek: number;
    maxOutputPerMonth: number;
    utilizationRate: number;   // 0-100 percentage
  }

  export type CostDriverType =
    | 'per-unit'
    | 'per-order'
    | 'per-service-hour'
    | 'per-machine-hour'
    | 'monthly'
    | 'quarterly'
    | 'yearly';

  export interface CostItem {
    category: string;
    type: 'variable' | 'fixed';
    rate: number;
    driverType: CostDriverType;
    driverQuantityPerMonth: number;
  }

  export interface OperationalMetric {
    name: string;
    unit: string;
    value: number;
    target: number;
  }

  export interface Operations {
    workforce: WorkforceMember[];
    capacity: CapacityConfig;
    costItems: CostItem[];
    equipment: string[];
    safetyProtocols: string[];
    operationalMetrics: OperationalMetric[];
  }
  ```

  Remove the old `CrewMember`, `CostBreakdown`, and `Operations` interfaces entirely.

  In `src/types/index.ts`, update re-exports:
  - Remove: `CrewMember`, `CostBreakdown`
  - Add: `WorkforceMember`, `CapacityConfig`, `CostItem`, `CostDriverType`, `OperationalMetric`
  - Keep: `Operations` (same name, new shape)

  Do NOT remove old types yet from the export if they're used in other files — the normalize function will handle backward compat. Actually, the old types are only used in the operations section editor and exports, which will be rewritten in later plans. Remove them.
  </action>
  <verify>`npx tsc --noEmit 2>&1 | head -30` — expect type errors in operations/index.tsx, section-prompts.ts, and export files (those will be fixed in Wave 2 plans). Confirm no errors in plan.ts or types/index.ts themselves.</verify>
  <done>
  - Old CrewMember, CostBreakdown, Operations removed from plan.ts
  - New WorkforceMember, CapacityConfig, CostItem, CostDriverType, OperationalMetric, Operations defined
  - types/index.ts re-exports updated
  </done>
</task>

<task type="auto">
  <name>Task 2: Create normalizeOperations migration and computeOperationsCosts functions</name>
  <files>src/features/sections/operations/normalize.ts, src/features/sections/operations/compute.ts</files>
  <action>
  **Create `src/features/sections/operations/normalize.ts`:**

  Follow the same pattern as `src/features/sections/product-service/normalize.ts`.

  ```ts
  import type { Operations, WorkforceMember, CostItem, OperationalMetric, CapacityConfig } from '@/types';

  export function normalizeOperations(raw: unknown): Operations {
    // ...
  }
  ```

  Handle three cases:
  1. **New format** (has `workforce` array + `costItems` array) → pass through, ensure all fields present with defaults
  2. **Legacy format** (has `crew` array + `costBreakdown` object) → migrate:
     - `crew[]` → `workforce[]` (map: `{ role, count, ratePerHour: hourlyRate }`)
     - `capacity.maxBookingsPerDay/Week/Month` → `capacity.maxOutputPerDay/Week/Month`, set `outputUnitLabel: 'bookings'`, `plannedOutputPerMonth: maxBookingsPerMonth`, `utilizationRate: 0`
     - `hoursPerEvent` and `travelRadius` → drop (no equivalent in new model)
     - `costBreakdown.*` per-event fields → variable `CostItem[]`:
       - Non-zero `suppliesPerChild` → `{ category: 'Supplies', type: 'variable', rate: suppliesPerChild * (participantsPerEvent || 1), driverType: 'per-unit', driverQuantityPerMonth: capacity.maxBookingsPerMonth || 0 }`
       - Non-zero `museumTicketPrice` → `{ category: 'Venue / Tickets', type: 'variable', rate: museumTicketPrice * (ticketsPerEvent || 1), driverType: 'per-unit', driverQuantityPerMonth: capacity.maxBookingsPerMonth || 0 }`
       - Non-zero fuel fields → `{ category: 'Transportation', type: 'variable', rate: (avgRoundTripMiles / Math.max(vehicleMPG, 1)) * fuelPricePerGallon + parkingPerEvent, driverType: 'per-unit', driverQuantityPerMonth: capacity.maxBookingsPerMonth || 0 }`
     - `costBreakdown.*` monthly fields → fixed `CostItem[]`:
       - Map each non-zero monthly field to a CostItem with `type: 'fixed'`, `driverType: 'monthly'`, `driverQuantityPerMonth: 1`. Category names: 'Owner Salary', 'Marketing Person', 'Event Coordinator', 'Vehicle Payment', 'Vehicle Maintenance', 'Vehicle Insurance', 'CRM Software', 'Website Hosting', 'AI & Chatbot', 'Cloud Services', 'Phone Plan', 'Content Creation', 'Graphic Design', 'Storage Rent', 'Equipment Amortization', 'Business Licenses', 'Miscellaneous Fixed'
     - `costBreakdown.customExpenses[]` → each maps to CostItem with `type: expense.type === 'per-event' ? 'variable' : 'fixed'`, `category: expense.name`, `rate: expense.amount`, appropriate driverType
     - `equipment[]` → keep as-is
     - `safetyProtocols[]` → keep as-is
     - `operationalMetrics` → `[]` (new field, no legacy equivalent)
  3. **Empty/null input** → return default empty Operations

  Default Operations:
  ```ts
  const defaultOperations: Operations = {
    workforce: [],
    capacity: { outputUnitLabel: '', plannedOutputPerMonth: 0, maxOutputPerDay: 0, maxOutputPerWeek: 0, maxOutputPerMonth: 0, utilizationRate: 0 },
    costItems: [],
    equipment: [],
    safetyProtocols: [],
    operationalMetrics: [],
  };
  ```

  **Create `src/features/sections/operations/compute.ts`:**

  Pure computation functions for cost summaries:

  ```ts
  import type { Operations, CostItem } from '@/types';

  export interface OperationsCostSummary {
    variableMonthlyTotal: number;
    fixedMonthlyTotal: number;
    monthlyOperationsTotal: number;
    variableCostPerOutput: number;
    workforceMonthlyTotal: number;
  }

  export function computeOperationsCosts(ops: Operations): OperationsCostSummary {
    const variableItems = ops.costItems.filter(i => i.type === 'variable');
    const fixedItems = ops.costItems.filter(i => i.type === 'fixed');

    const variableMonthlyTotal = variableItems.reduce((sum, item) =>
      sum + item.rate * item.driverQuantityPerMonth, 0);

    const fixedMonthlyTotal = fixedItems.reduce((sum, item) => {
      // Normalize to monthly
      switch (item.driverType) {
        case 'quarterly': return sum + (item.rate * item.driverQuantityPerMonth) / 3;
        case 'yearly': return sum + (item.rate * item.driverQuantityPerMonth) / 12;
        default: return sum + item.rate * item.driverQuantityPerMonth;
      }
    }, 0);

    const workforceMonthlyTotal = ops.workforce.reduce((sum, w) =>
      sum + w.ratePerHour * w.count * 160, 0); // ~160 hours/month per worker

    const monthlyOperationsTotal = variableMonthlyTotal + fixedMonthlyTotal + workforceMonthlyTotal;

    const variableCostPerOutput = ops.capacity.plannedOutputPerMonth > 0
      ? variableMonthlyTotal / ops.capacity.plannedOutputPerMonth
      : 0;

    return { variableMonthlyTotal, fixedMonthlyTotal, monthlyOperationsTotal, variableCostPerOutput, workforceMonthlyTotal };
  }
  ```

  Export both functions.
  </action>
  <verify>`npx tsc --noEmit 2>&1 | grep -c "error"` — normalize.ts and compute.ts should have 0 type errors (they only import from @/types)</verify>
  <done>
  - normalizeOperations handles new format, legacy format, and empty input
  - computeOperationsCosts returns variableMonthlyTotal, fixedMonthlyTotal, monthlyOperationsTotal, variableCostPerOutput, workforceMonthlyTotal
  - Legacy CostBreakdown fields mapped to generic CostItem[] with appropriate categories and driver types
  - Both functions are pure, no side effects
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] New types compile: WorkforceMember, CapacityConfig, CostItem, CostDriverType, OperationalMetric, Operations
- [ ] Old types removed: CrewMember, CostBreakdown
- [ ] normalizeOperations handles legacy data with CostBreakdown → CostItem[] mapping
- [ ] computeOperationsCosts derives correct totals
- [ ] No type errors in the new files themselves (downstream errors expected and OK)
</verification>

<success_criteria>

- Generic Operations types replace event-specific types
- Normalization function provides backward-compatible migration
- Cost computation is a pure function ready for UI consumption
- All new code is type-safe
</success_criteria>

<output>
After completion, create `.planning/phases/20-generic-industry-agnostic-operations/20-01-SUMMARY.md`
</output>
