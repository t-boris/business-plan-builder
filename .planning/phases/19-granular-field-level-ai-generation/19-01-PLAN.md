---
phase: 19-granular-field-level-ai-generation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/hooks/use-field-ai.ts, src/lib/ai/context-builder.ts, src/components/ai-field-trigger.tsx]
autonomous: true
---

<objective>
Create the reusable infrastructure for per-field AI generation: a lightweight hook, prompt builder, and trigger component.

Purpose: Enable any Textarea field in any section to have its own AI generation/improvement button, independent of the whole-tab AI flow.
Output: `useFieldAi` hook, `buildFieldPrompt` function, `AiFieldTrigger` component.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/hooks/use-ai-suggestion.ts
@src/lib/ai/context-builder.ts
@src/lib/ai/gemini-client.ts
@src/lib/ai/section-prompts.ts
@src/components/ai-action-bar.tsx
@src/components/ai-suggestion-preview.tsx
@src/store/business-atoms.ts
@src/store/scenario-atoms.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useFieldAi hook and buildFieldPrompt</name>
  <files>src/hooks/use-field-ai.ts, src/lib/ai/context-builder.ts</files>
  <action>
  **1. Add `buildFieldPrompt` to `context-builder.ts`:**

  Add a new exported function at the end of the file:

  ```ts
  export function buildFieldPrompt(config: {
    fieldName: string;
    fieldLabel: string;
    currentValue: string;
    action: 'generate' | 'improve';
    sectionSlug: string;
    sectionData: Record<string, unknown>;
    businessProfile: { name: string; type: string; industry: string; location: string; description: string };
    scenarioV2Context?: string;
  }): string
  ```

  The function builds a prompt with these XML blocks:
  - `<business_profile>` — from `buildBusinessProfile(config.businessProfile)`
  - `<current_section slug="...">` — `JSON.stringify(config.sectionData, null, 2)` (same pattern as existing `buildPrompt`)
  - `<active_scenario>` — only if `scenarioV2Context` is provided
  - `<task>` — the field-specific instruction:
    - For `generate`: "Write the '{fieldLabel}' field for the {sectionSlug} section. Use the business profile and current section data as context. Return ONLY the text content for this single field, nothing else. Be specific to this business."
    - For `improve`: "Improve the following '{fieldLabel}' text. Make it more specific, professional, and aligned with the business context. Current text: \"{currentValue}\". Return ONLY the improved text, nothing else."

  Do NOT call `getSectionPrompt` — the field prompt is simpler and doesn't need the whole-section instruction.

  **2. Create `src/hooks/use-field-ai.ts`:**

  A lightweight hook specifically for single-field AI generation. Much simpler than `useAiSuggestion`:

  ```ts
  interface FieldAiState {
    status: 'idle' | 'loading' | 'error';
    error: string | null;
  }

  export function useFieldAi(sectionSlug: SectionSlug) {
    // Returns: { state, generate }
  }
  ```

  The `generate` function signature:
  ```ts
  async function generate(config: {
    fieldName: string;
    fieldLabel: string;
    currentValue: string;
    action: 'generate' | 'improve';
    sectionData: Record<string, unknown>;
  }): Promise<string | null>
  ```

  Implementation:
  1. Read atoms: `activeBusinessAtom` (for profile), scenario atoms (for v2 context) — same pattern as `useAiSuggestion` lines 35-42
  2. Build system prompt via `buildSystemPrompt(profile)` — import from existing location
  3. Build field prompt via `buildFieldPrompt(...)` with all context
  4. Call `generateSectionContent(prompt, systemInstruction)` — free-text generation, no schema needed
  5. Return the generated string (trimmed), or null on error
  6. Set state to loading/idle/error appropriately

  The hook does NOT have preview/accept/reject — it returns the string directly. The calling component decides what to do with it (replace field, show confirmation, etc.).

  Follow the same atom reading pattern as `useAiSuggestion` (useAtomValue for each atom). Import `buildSystemPrompt` from `section-prompts.ts` — check if it's exported, if not, extract and export it.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit 2>&1 | head -20` shows no errors in new files</verify>
  <done>
  - `buildFieldPrompt` exported from `context-builder.ts` with proper XML structure
  - `useFieldAi` hook exported from `use-field-ai.ts`
  - Hook reads business profile and scenario context from atoms
  - Hook calls `generateSectionContent` (free text) and returns string
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AiFieldTrigger component</name>
  <files>src/components/ai-field-trigger.tsx</files>
  <action>
  Create a small inline component that renders a sparkle icon button next to any text field.

  **Props:**
  ```ts
  interface AiFieldTriggerProps {
    fieldName: string;
    fieldLabel: string;
    currentValue: string;
    sectionSlug: SectionSlug;
    sectionData: Record<string, unknown>;
    onResult: (value: string) => void;
    disabled?: boolean;
  }
  ```

  **Behavior:**
  1. Renders a small ghost button with `Sparkles` icon (from lucide-react), sized `size-3.5`
  2. The button has a tooltip: "AI: Generate" if `currentValue` is empty, "AI: Improve" if it has content
  3. On click:
     - Calls `useFieldAi(sectionSlug).generate(...)` with action = `currentValue ? 'improve' : 'generate'`
     - While loading: replaces Sparkles with `Loader2` with `animate-spin`
     - On success: calls `onResult(generatedText)`
     - On error: shows a brief toast/tooltip with error message (use the existing Tooltip pattern from the codebase)
  4. When `disabled` is true, the button is hidden (don't render at all — keeps UI clean for viewers)

  **Styling:**
  - Match the existing ghost button pattern: `variant="ghost" size="icon-xs"`
  - Sparkles icon color: `text-violet-400 hover:text-violet-500` (subtle but discoverable)
  - Position: inline, meant to be placed in a `<label>` row or next to field headers

  **Important:** The hook instance (`useFieldAi`) must be called at component level (React rules of hooks). The `generate` function is called on click.

  Import `Tooltip`, `TooltipTrigger`, `TooltipContent` from `@/components/ui/tooltip` for the tooltip.
  Import `Sparkles`, `Loader2` from `lucide-react`.
  Import `Button` from `@/components/ui/button`.
  Import `useFieldAi` from `@/hooks/use-field-ai`.
  Import `SectionSlug` from `@/types`.
  </action>
  <verify>`npx vite build 2>&1 | tail -5` — build succeeds with no errors</verify>
  <done>
  - `AiFieldTrigger` component exported from `src/components/ai-field-trigger.tsx`
  - Shows sparkle icon, auto-detects generate vs improve action
  - Calls `useFieldAi` hook, shows loading spinner, invokes `onResult` callback
  - Follows existing UI patterns (ghost button, tooltip, lucide icons)
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx vite build` succeeds without errors
- [ ] `npx vitest run` — all existing tests still pass
- [ ] New hook follows same atom-reading pattern as `useAiSuggestion`
- [ ] Component uses existing UI patterns (Button, Tooltip, lucide icons)
</verification>

<success_criteria>

- `useFieldAi` hook created and working (reads atoms, builds prompt, calls Gemini, returns string)
- `buildFieldPrompt` function added to context-builder.ts
- `AiFieldTrigger` component created with generate/improve auto-detection
- All existing functionality unaffected
- Build and tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/19-granular-field-level-ai-generation/19-01-SUMMARY.md`
</output>
