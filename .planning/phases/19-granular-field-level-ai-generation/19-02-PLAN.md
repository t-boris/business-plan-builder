---
phase: 19-granular-field-level-ai-generation
plan: 02
type: execute
wave: 2
depends_on: ["19-01"]
files_modified: [src/features/sections/executive-summary/index.tsx, src/features/sections/product-service/index.tsx, src/features/sections/marketing-strategy/index.tsx, src/features/sections/market-analysis/index.tsx, src/features/sections/market-analysis/components/sizing-block.tsx, src/features/sections/risks-due-diligence/index.tsx]
autonomous: true
---

<objective>
Wire AiFieldTrigger into all section editors that have rich text fields suitable for per-field AI generation.

Purpose: Users can now generate or improve individual text fields (descriptions, overviews, narratives, mitigations) without regenerating the entire section.
Output: 5 section editors enhanced with per-field AI triggers on eligible Textarea fields.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-granular-field-level-ai-generation/19-01-SUMMARY.md

@src/components/ai-field-trigger.tsx
@src/hooks/use-field-ai.ts
@src/features/sections/executive-summary/index.tsx
@src/features/sections/product-service/index.tsx
@src/features/sections/marketing-strategy/index.tsx
@src/features/sections/market-analysis/index.tsx
@src/features/sections/market-analysis/components/sizing-block.tsx
@src/features/sections/risks-due-diligence/index.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire AiFieldTrigger into executive-summary, product-service, and marketing-strategy</name>
  <files>src/features/sections/executive-summary/index.tsx, src/features/sections/product-service/index.tsx, src/features/sections/marketing-strategy/index.tsx</files>
  <action>
  For each section, import `AiFieldTrigger` and add it to eligible Textarea fields. The trigger should appear inline in the label row (next to the `<label>` text), only when `canEdit && !isPreview`.

  **Pattern for adding a trigger to a field:**

  Replace:
  ```tsx
  <label className="text-sm font-medium">Description</label>
  ```
  With:
  ```tsx
  <label className="text-sm font-medium flex items-center gap-1">
    Description
    {canEdit && !isPreview && (
      <AiFieldTrigger
        fieldName="description"
        fieldLabel="Description"
        currentValue={data.someField}
        sectionSlug="section-slug"
        sectionData={data as unknown as Record<string, unknown>}
        onResult={(val) => updateField('someField', val)}
      />
    )}
  </label>
  ```

  **Executive Summary** (`executive-summary/index.tsx`):
  Add triggers to these 3 Textarea fields:
  - `summary` field — label "Summary", onResult calls `updateField('summary', val)` or equivalent `updateData` pattern
  - `mission` field — label "Mission"
  - `vision` field — label "Vision"

  Note: `keyHighlights` is an array of short inputs — skip it (not a good fit for per-field AI).

  The section uses `updateData` pattern. For each field trigger's `onResult`, call:
  ```tsx
  onResult={(val) => updateData((prev) => ({ ...prev, summary: val }))}
  ```

  **Product & Service** (`product-service/index.tsx`):
  Add triggers to:
  - `overview` Textarea (top of section) — fieldName="overview", onResult updates overview
  - Per-offering `description` Textarea (inside the offering card loop) — fieldName should include offering context, e.g. `fieldName="offering-description"`, fieldLabel=`"Description for ${offering.name || 'Offering'}"`. The onResult needs to update the specific offering in the array.

  For per-offering description, the onResult callback should:
  ```tsx
  onResult={(val) => updateData((prev) => {
    const offerings = [...prev.offerings];
    offerings[index] = { ...offerings[index], description: val };
    return { ...prev, offerings };
  })}
  ```

  **Marketing Strategy** (`marketing-strategy/index.tsx`):
  Add triggers to:
  - Per-channel `description` Textarea — fieldName="channel-description", fieldLabel=`"Description for ${channel.name || 'Channel'}"`. onResult calls `updateChannel(chIndex, 'description', val)`.
  - `landingPage.description` Textarea — fieldName="landing-page-description", fieldLabel="Landing Page Description". onResult updates via `updateData`.

  Do NOT add triggers to: short inputs (channel name, URL, budget), tactics (short strings), offers (short strings).
  </action>
  <verify>`npx vite build 2>&1 | tail -5` — build succeeds</verify>
  <done>
  - Executive Summary: 3 fields have AiFieldTrigger (summary, mission, vision)
  - Product & Service: 2 field types have triggers (overview, per-offering description)
  - Marketing Strategy: 2 field types have triggers (per-channel description, landing page description)
  - Triggers only visible when canEdit && !isPreview
  - Build passes
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire AiFieldTrigger into market-analysis and risks-due-diligence</name>
  <files>src/features/sections/market-analysis/index.tsx, src/features/sections/market-analysis/components/sizing-block.tsx, src/features/sections/risks-due-diligence/index.tsx</files>
  <action>
  **Market Analysis:**

  The market-analysis section delegates to sub-components. The main narrative field (`marketNarrative`) is in the sizing block component.

  In `sizing-block.tsx` (or wherever `marketNarrative` Textarea is rendered):
  - Add AiFieldTrigger to the `marketNarrative` Textarea label
  - fieldName="marketNarrative", fieldLabel="Market Narrative"
  - sectionSlug="market-analysis"
  - sectionData should be the full market analysis data (may need to pass it as prop or read from the section hook)
  - onResult updates the marketNarrative field

  Check if the sizing block has direct access to `updateData` or if it receives an `onChange` prop. Wire accordingly.

  Note: Competitor `strengths`/`weaknesses` fields are short Inputs in a table — skip them (they're single-line, not rich text). Funnel stage `description` fields are also short Inputs — skip.

  **Risks & Due Diligence** (`risks-due-diligence/index.tsx`):
  Add triggers to:
  - Per-risk `description` Textarea — fieldName="risk-description", fieldLabel=`"Description for risk: ${risk.title || 'Risk'}"`. onResult updates the specific risk in the array.
  - Per-risk `mitigation` Textarea — fieldName="risk-mitigation", fieldLabel=`"Mitigation for: ${risk.title || 'Risk'}"`. onResult updates the specific risk.
  - Per-DD-item `detail` Textarea (if due diligence items have Textarea for detail) — fieldName="dd-item-detail", fieldLabel=`"Detail for: ${item.item}"`. onResult updates the specific DD item.

  For array item updates, follow the same pattern as product-service offerings:
  ```tsx
  onResult={(val) => updateData((prev) => {
    const risks = [...prev.risks];
    risks[index] = { ...risks[index], description: val };
    return { ...prev, risks };
  })}
  ```

  After wiring both sections, do a final verification.
  </action>
  <verify>
  Run full verification:
  1. `npx vite build 2>&1 | tail -5` — build succeeds
  2. `npx vitest run 2>&1 | tail -10` — all tests pass
  3. `npm run lint 2>&1 | tail -10` — no lint errors
  </verify>
  <done>
  - Market Analysis: marketNarrative has AiFieldTrigger
  - Risks & Due Diligence: per-risk description, per-risk mitigation, and per-DD-item detail have triggers
  - All triggers only visible when canEdit && !isPreview
  - Build, tests, and lint pass
  - The whole-tab AI (AiActionBar) still works alongside per-field triggers
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx vite build` succeeds without errors
- [ ] `npx vitest run` — all tests pass (65+)
- [ ] `npm run lint` — no errors
- [ ] Executive Summary: 3 AiFieldTrigger instances (summary, mission, vision)
- [ ] Product & Service: triggers on overview + per-offering description
- [ ] Marketing Strategy: triggers on per-channel description + landing page description
- [ ] Market Analysis: trigger on marketNarrative
- [ ] Risks & Due Diligence: triggers on per-risk description, mitigation, per-DD-item detail
- [ ] Existing whole-tab AI (Generate/Improve/Expand) still works on all sections
- [ ] Triggers hidden for viewers (canEdit check)
</verification>

<success_criteria>

- All 5 section editors have per-field AI triggers on eligible Textarea fields
- Triggers auto-detect generate (empty) vs improve (has content) mode
- Triggers are only visible to editors (not viewers, not during AI preview)
- Whole-tab AI generation still works alongside field-level triggers
- Build, lint, and all tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/19-granular-field-level-ai-generation/19-02-SUMMARY.md`
</output>
