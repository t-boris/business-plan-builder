---
phase: 09-sharing-access
plan: 03
type: execute
wave: 2
depends_on: ["09-01"]
files_modified: [src/hooks/use-business-role.ts, src/hooks/use-section.ts, src/hooks/use-ai-suggestion.ts, src/features/scenarios/scenario-manager.tsx, src/features/scenarios/index.tsx, src/components/ai-action-bar.tsx]
autonomous: true
---

<objective>
Enforce read-only mode for viewers across all editable surfaces.

Purpose: Viewers can see everything but cannot modify data. All section forms, scenario controls, and AI generation are disabled for viewers. This completes the viewer role enforcement client-side (Firestore rules handle server-side enforcement from 09-01).
Output: useBusinessRole hook, role-aware useSection (skips saves), disabled UI for viewers.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-sharing-access/09-RESEARCH.md
@.planning/phases/09-sharing-access/09-CONTEXT.md
@.planning/phases/09-sharing-access/09-01-SUMMARY.md

@src/hooks/use-section.ts
@src/hooks/use-ai-suggestion.ts
@src/features/scenarios/scenario-manager.tsx
@src/features/scenarios/index.tsx
@src/components/ai-action-bar.tsx
@src/components/app-sidebar.tsx
@src/store/business-atoms.ts
@src/types/business.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useBusinessRole hook and make useSection role-aware</name>
  <files>src/hooks/use-business-role.ts, src/hooks/use-section.ts</files>
  <action>
  **Create `src/hooks/use-business-role.ts`:**

  A simple hook that returns the current user's role on the active business:

  ```typescript
  import { useAtomValue } from "jotai";
  import { activeBusinessAtom } from "@/store/business-atoms";
  import { useAuth } from "@/hooks/use-auth";
  import type { BusinessRole } from "@/types";

  /**
   * Returns the current user's role on the active business.
   * Returns null if no business is active or user has no role.
   */
  export function useBusinessRole(): BusinessRole | null {
    const business = useAtomValue(activeBusinessAtom);
    const { user } = useAuth();
    if (!business || !user) return null;
    return business.roles[user.uid] ?? null;
  }

  /**
   * Returns true if the current user can edit the active business.
   * Only owners and editors can edit. Viewers and unauthenticated users cannot.
   */
  export function useCanEdit(): boolean {
    const role = useBusinessRole();
    return role === "owner" || role === "editor";
  }
  ```

  **Update `src/hooks/use-section.ts`:**

  Make the section hook role-aware â€” viewers should still see data but saves should be silently skipped:

  1. Import `useCanEdit` from `@/hooks/use-business-role`
  2. Call `const canEdit = useCanEdit();` inside the hook
  3. Add `canEdit` to the return type:
     ```typescript
     interface UseSectionReturn<T> {
       data: T;
       updateField: <K extends keyof T>(field: K, value: T[K]) => void;
       updateData: (updater: (prev: T) => T) => void;
       isLoading: boolean;
       canEdit: boolean;
     }
     ```
  4. In `debounceSave`, add an early return if `!canEdit`:
     ```typescript
     const debounceSave = useCallback(
       (newData: T) => {
         if (!businessId || !canEdit) return;
         // ... existing debounce logic
       },
       [businessId, sectionSlug, canEdit]
     );
     ```
  5. Return `canEdit` in the return object:
     ```typescript
     return { data, updateField, updateData, isLoading, canEdit };
     ```

  This approach is clean: local state still updates (so the preview/display works), but saves are silently skipped. Section components can check `canEdit` to disable form fields.
  </action>
  <verify>Run `npx tsc --noEmit`. Verify `useBusinessRole` and `useCanEdit` are exported. Verify `useSection` returns `canEdit` boolean. Verify `debounceSave` checks `canEdit`.</verify>
  <done>useBusinessRole and useCanEdit hooks created. useSection returns canEdit and skips Firestore saves for viewers. No breaking changes to existing consumers (canEdit is additive).</done>
</task>

<task type="auto">
  <name>Task 2: Disable editing UI for viewers across all surfaces</name>
  <files>src/features/sections/executive-summary/index.tsx, src/features/sections/market-analysis/index.tsx, src/features/sections/product-service/index.tsx, src/features/sections/marketing-strategy/index.tsx, src/features/sections/operations/index.tsx, src/features/sections/financial-projections/index.tsx, src/features/sections/risks-due-diligence/index.tsx, src/features/sections/kpis-metrics/index.tsx, src/features/sections/launch-plan/index.tsx, src/components/ai-action-bar.tsx, src/features/scenarios/scenario-manager.tsx, src/features/scenarios/index.tsx</files>
  <action>
  **Pattern for all 9 section components:**

  Each section already destructures `useSection`:
  ```typescript
  const { data, updateField, updateData, isLoading } = useSection<T>(slug, defaults);
  ```

  Update to:
  ```typescript
  const { data, updateField, updateData, isLoading, canEdit } = useSection<T>(slug, defaults);
  ```

  Then add `disabled={!canEdit}` or `readOnly={!canEdit}` to all `<Input>`, `<Textarea>`, and `<Select>` elements. For buttons that add/remove list items (like key highlights in executive-summary), conditionally render them:
  ```tsx
  {canEdit && (
    <Button onClick={handleAdd}>
      <Plus className="size-4" /> Add Item
    </Button>
  )}
  ```

  Apply this pattern to all 9 section files:
  - `src/features/sections/executive-summary/index.tsx`
  - `src/features/sections/market-analysis/index.tsx`
  - `src/features/sections/product-service/index.tsx`
  - `src/features/sections/marketing-strategy/index.tsx`
  - `src/features/sections/operations/index.tsx`
  - `src/features/sections/financial-projections/index.tsx`
  - `src/features/sections/risks-due-diligence/index.tsx`
  - `src/features/sections/kpis-metrics/index.tsx`
  - `src/features/sections/launch-plan/index.tsx`

  **Update `src/components/ai-action-bar.tsx`:**

  The AI action bar provides generate/improve/expand buttons. Hide the entire bar for viewers:

  1. Import `useCanEdit` from `@/hooks/use-business-role`
  2. At the top of the component: `const canEdit = useCanEdit();`
  3. Early return if viewer: `if (!canEdit) return null;`

  This hides AI generation completely for viewers (they can't save the results anyway).

  **Update `src/features/scenarios/scenario-manager.tsx`:**

  Disable scenario creation and deletion for viewers:

  1. Import `useCanEdit` from `@/hooks/use-business-role`
  2. `const canEdit = useCanEdit();`
  3. Disable "New Scenario" button: `disabled={!canEdit}`
  4. Conditionally render delete button: `{canEdit && <Button ...>}`

  **Update `src/features/scenarios/index.tsx`:**

  If the scenario page has inline editing controls (variable sliders/inputs), disable them for viewers:

  1. Import `useCanEdit` from `@/hooks/use-business-role`
  2. `const canEdit = useCanEdit();`
  3. Add `disabled={!canEdit}` to all slider/input controls
  4. Keep charts and display data visible (viewers can see scenario data, just not modify)
  </action>
  <verify>Run `npx tsc --noEmit` and `npm run build`. Grep for `canEdit` in all section files to confirm the pattern was applied. Verify AiActionBar returns null for viewers. Verify ScenarioManager disables creation/deletion for viewers.</verify>
  <done>All 9 section forms disabled for viewers. AI action bar hidden for viewers. Scenario creation/deletion disabled. Scenario viewing (charts, data) still works. Full TypeScript compilation passes.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes with zero errors
- [ ] `npm run build` succeeds
- [ ] `useBusinessRole` returns correct role for current user
- [ ] `useCanEdit` returns false for viewers, true for owner/editor
- [ ] `useSection` returns `canEdit` and skips saves when false
- [ ] All 9 section components use `canEdit` to disable form fields
- [ ] AI action bar hidden for viewers
- [ ] Scenario manager disables create/delete for viewers
- [ ] Scenario viewing (charts, comparisons) still works for viewers
- [ ] No breaking changes to existing owner/editor functionality
</verification>

<success_criteria>

- Viewers see all data but cannot modify anything
- All form inputs disabled/readOnly for viewers
- AI generation hidden for viewers
- Scenario management restricted for viewers (view-only)
- Existing owner/editor flows unchanged
- Full TypeScript compilation and build pass
</success_criteria>

<output>
After completion, create `.planning/phases/09-sharing-access/09-03-SUMMARY.md`
</output>
