---
phase: 09-sharing-access
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/types/business.ts, src/types/index.ts, src/lib/business-firestore.ts, firestore.rules, src/store/auth-atoms.ts, src/app/providers.tsx]
autonomous: true
---

<objective>
Update the data model, security rules, and auth layer for sharing and multi-role access.

Purpose: Establish the foundation for sharing — viewer role, reusable invite links, tightened Firestore security rules, and removal of the email whitelist. After this plan, the data layer supports creating invites, accepting them, and role-based access (owner/editor/viewer).
Output: Updated types, invite CRUD functions in business-firestore.ts, viewer-aware security rules with invite acceptance path, no ALLOWED_EMAILS whitelist.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-sharing-access/09-RESEARCH.md
@.planning/phases/09-sharing-access/09-CONTEXT.md

@src/types/business.ts
@src/types/index.ts
@src/lib/business-firestore.ts
@firestore.rules
@src/store/auth-atoms.ts
@src/app/providers.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update types and add invite CRUD functions</name>
  <files>src/types/business.ts, src/lib/business-firestore.ts</files>
  <action>
  **Update `src/types/business.ts`:**

  1. Add `viewer` to `BusinessRole`:
     ```typescript
     export type BusinessRole = "owner" | "editor" | "viewer";
     ```

  2. Simplify `InviteStatus` for reusable links:
     ```typescript
     export type InviteStatus = "active" | "revoked";
     ```

  3. Simplify `BusinessInvite` for reusable links — remove single-use fields:
     ```typescript
     export interface BusinessInvite {
       id: string;
       businessId: string;
       role: BusinessRole;
       createdBy: string;
       status: InviteStatus;
       createdAt: string;
     }
     ```
     Remove: `token` (doc ID is the token), `expiresAt` (no expiration for reusable links), `acceptedBy`/`acceptedAt` (multiple users can accept the same link).

  **Add invite CRUD to `src/lib/business-firestore.ts`:**

  Add these functions in a new `// Invites` section after the existing `// Share / Role Management` section:

  ```typescript
  // =============================================================================
  // Invites
  // =============================================================================

  // Firestore path: invites/{inviteId}

  /**
   * Create a reusable invite link for a business.
   * The invite document ID is the share token (UUID v4).
   * Returns the invite ID (which IS the URL token).
   */
  export async function createInvite(
    businessId: string,
    role: BusinessRole,
    createdBy: string
  ): Promise<string> {
    const inviteId = crypto.randomUUID();
    await setDoc(doc(db, "invites", inviteId), {
      businessId,
      role,
      createdBy,
      status: "active",
      createdAt: new Date().toISOString(),
    });
    return inviteId;
  }

  /**
   * Get an invite by ID (the share token).
   */
  export async function getInvite(
    inviteId: string
  ): Promise<BusinessInvite | null> {
    const snap = await getDoc(doc(db, "invites", inviteId));
    if (!snap.exists()) return null;
    return { id: snap.id, ...snap.data() } as BusinessInvite;
  }

  /**
   * List active invites for a business (for the owner's share panel).
   * Requires composite index: invites (businessId ASC, status ASC).
   */
  export async function listBusinessInvites(
    businessId: string
  ): Promise<BusinessInvite[]> {
    const q = query(
      collection(db, "invites"),
      where("businessId", "==", businessId),
      where("status", "==", "active")
    );
    const snap = await getDocs(q);
    return snap.docs.map((d) => ({ id: d.id, ...d.data() }) as BusinessInvite);
  }

  /**
   * Revoke an invite (sets status to 'revoked').
   */
  export async function revokeInvite(inviteId: string): Promise<void> {
    await updateDoc(doc(db, "invites", inviteId), {
      status: "revoked",
    });
  }

  /**
   * Delete an invite document entirely.
   */
  export async function deleteInvite(inviteId: string): Promise<void> {
    await deleteDoc(doc(db, "invites", inviteId));
  }

  /**
   * Accept an invite — add the accepting user to the business roles map.
   * Uses _acceptingInviteId for security rule verification via get().
   * The invite stays 'active' (reusable link pattern).
   */
  export async function acceptInvite(
    inviteId: string,
    businessId: string,
    role: BusinessRole,
    uid: string
  ): Promise<void> {
    await updateDoc(doc(db, "businesses", businessId), {
      [`roles.${uid}`]: role,
      updatedAt: new Date().toISOString(),
      _acceptingInviteId: inviteId,
    });
  }
  ```

  Import `BusinessInvite` type at the top of business-firestore.ts (add to existing import from `@/types`).

  Note: `acceptInvite` uses a standalone `updateDoc` (not writeBatch) because the invite stays active — no status transition needed. The security rule validates via `get()` on the invite doc.
  </action>
  <verify>Run `npx tsc --noEmit` — must compile. Grep for `createInvite` and `acceptInvite` in business-firestore.ts. Verify `BusinessRole` includes `"viewer"`. Verify `BusinessInvite` no longer has `token`, `expiresAt`, `acceptedBy`, `acceptedAt` fields.</verify>
  <done>BusinessRole includes viewer. BusinessInvite simplified for reusable links. Six invite functions exported from business-firestore.ts. TypeScript compiles.</done>
</task>

<task type="auto">
  <name>Task 2: Rewrite Firestore security rules with viewer role and invite acceptance</name>
  <files>firestore.rules</files>
  <action>
  **Rewrite `firestore.rules`** with three major changes:

  1. **Viewer read access**: Viewers can read business doc and all subcollections, but cannot write.
  2. **Invite acceptance self-add**: Authenticated user can add themselves to roles map IF a valid active invite exists.
  3. **Tightened invite rules**: Only business owner can create invites. Only creator can revoke/delete.

  Full replacement:

  ```
  rules_version = '2';

  service cloud.firestore {
    match /databases/{database}/documents {

      // --- Templates: read-only for authenticated users ---
      match /templates/{templateId} {
        allow read: if request.auth != null;
        allow write: if false;
      }

      // --- Businesses: role-based access via roles map ---
      match /businesses/{businessId} {

        function hasRole(roles) {
          return request.auth != null
            && request.auth.uid in resource.data.roles
            && resource.data.roles[request.auth.uid] in roles;
        }

        function isOnlySelfAddToRoles() {
          let rolesDiff = request.resource.data.roles.diff(resource.data.roles);
          return rolesDiff.addedKeys().hasOnly([request.auth.uid])
            && rolesDiff.addedKeys().size() == 1
            && rolesDiff.changedKeys().size() == 0
            && rolesDiff.removedKeys().size() == 0
            && request.resource.data.roles[request.auth.uid] in ['editor', 'viewer'];
        }

        function isValidInviteAcceptance(businessId) {
          let inviteId = request.resource.data._acceptingInviteId;
          let invite = get(/databases/$(database)/documents/invites/$(inviteId));
          return invite != null
            && invite.data.status == 'active'
            && invite.data.businessId == businessId
            && request.resource.data.roles[request.auth.uid] == invite.data.role;
        }

        // Any authenticated user can create a business (they become owner)
        allow create: if request.auth != null
          && request.resource.data.roles[request.auth.uid] == 'owner';

        // Owner, editor, and viewer can read
        allow read: if hasRole(['owner', 'editor', 'viewer']);

        // Owner and editor can update normally
        // OR: any authenticated user can accept a valid invite (self-add to roles)
        allow update: if hasRole(['owner', 'editor'])
          || (
            request.auth != null
            && '_acceptingInviteId' in request.resource.data
            && request.resource.data.diff(resource.data).affectedKeys()
                 .hasOnly(['roles', 'updatedAt', '_acceptingInviteId'])
            && isOnlySelfAddToRoles()
            && isValidInviteAcceptance(businessId)
          );

        // Only owner can delete
        allow delete: if hasRole(['owner']);

        // --- Sections: owner+editor write, viewer read-only ---
        match /sections/{sectionKey} {
          allow read: if get(/databases/$(database)/documents/businesses/$(businessId))
                         .data.roles[request.auth.uid] in ['owner', 'editor', 'viewer'];
          allow write: if get(/databases/$(database)/documents/businesses/$(businessId))
                          .data.roles[request.auth.uid] in ['owner', 'editor'];
        }

        // --- Scenarios: owner+editor write, viewer read-only ---
        match /scenarios/{scenarioId} {
          allow read: if get(/databases/$(database)/documents/businesses/$(businessId))
                         .data.roles[request.auth.uid] in ['owner', 'editor', 'viewer'];
          allow write: if get(/databases/$(database)/documents/businesses/$(businessId))
                          .data.roles[request.auth.uid] in ['owner', 'editor'];
        }

        // --- Business state/preferences: owner+editor write, viewer read-only ---
        match /state/{stateDoc} {
          allow read: if get(/databases/$(database)/documents/businesses/$(businessId))
                         .data.roles[request.auth.uid] in ['owner', 'editor', 'viewer'];
          allow write: if get(/databases/$(database)/documents/businesses/$(businessId))
                          .data.roles[request.auth.uid] in ['owner', 'editor'];
        }
      }

      // --- Users: own profile only ---
      match /users/{userId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }

      // --- Invites ---
      match /invites/{inviteId} {
        // Any authenticated user can read an invite (they need the ID to find it)
        allow read: if request.auth != null;

        // Only business owner can create invites
        allow create: if request.auth != null
          && request.resource.data.status == 'active'
          && request.resource.data.createdBy == request.auth.uid
          && get(/databases/$(database)/documents/businesses/$(request.resource.data.businessId))
               .data.roles[request.auth.uid] == 'owner';

        // Only creator can revoke (update status to 'revoked')
        allow update: if request.auth != null
          && resource.data.createdBy == request.auth.uid
          && request.resource.data.status == 'revoked'
          && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status']);

        // Only creator can delete
        allow delete: if request.auth != null
          && resource.data.createdBy == request.auth.uid;
      }

      // --- Legacy: keep existing plans path working ---
      match /plans/{planId}/{document=**} {
        allow read, write: if request.auth != null;
      }
    }
  }
  ```

  Key changes from existing rules:
  - Added `viewer` to all read rules for business doc + subcollections
  - Subcollection write rules remain owner+editor only (viewers cannot write)
  - Added `isOnlySelfAddToRoles()` and `isValidInviteAcceptance()` functions
  - Business update rule has OR branch for invite acceptance
  - Invite create requires owner role verified via `get()` on business doc
  - Invite update restricted to status→revoked by creator only
  - Uses `get()` (not `getAfter()`) because invite stays active (reusable link pattern)
  </action>
  <verify>Read firestore.rules and verify: `viewer` appears in all read rules, `isOnlySelfAddToRoles` function exists, `isValidInviteAcceptance` function exists, invite create checks owner role via get(), invite update restricted to revoke only.</verify>
  <done>Firestore rules support viewer read-only access, invite acceptance self-add pattern, and owner-only invite management. All subcollection rules updated for viewer read access.</done>
</task>

<task type="auto">
  <name>Task 3: Remove ALLOWED_EMAILS whitelist</name>
  <files>src/store/auth-atoms.ts, src/app/providers.tsx</files>
  <action>
  **Update `src/store/auth-atoms.ts`:**

  Remove the `ALLOWED_EMAILS` constant entirely. Remove its `as const` typing. Remove the `'denied'` status from `AuthStatus`:

  ```typescript
  export type AuthStatus = 'loading' | 'authenticated' | 'unauthenticated';
  ```

  **Update `src/app/providers.tsx`:**

  In `AuthListener`:
  1. Remove the import of `ALLOWED_EMAILS` from `@/store/auth-atoms`
  2. Remove the email checking logic:
     ```typescript
     const email = user.email?.toLowerCase() ?? '';
     const isAllowed = ALLOWED_EMAILS.includes(email as typeof ALLOWED_EMAILS[number]);
     ```
  3. Simplify the auth state update to always authenticate if user exists:
     ```typescript
     setAuthState({
       status: 'authenticated',
       user,
     });
     ```

  Access control is now handled entirely by Firestore roles. Any authenticated user can use the app, but they can only see businesses where they have a role.

  Grep for `ALLOWED_EMAILS` and `'denied'` across the entire codebase to ensure no other references remain. If any exist (e.g., in router.tsx or login-page), update them too.
  </action>
  <verify>Grep for `ALLOWED_EMAILS` — should find zero results. Grep for `'denied'` in auth context — should find zero results. Run `npx tsc --noEmit` — must compile. Run `npm run build` — must succeed.</verify>
  <done>ALLOWED_EMAILS whitelist removed. Any authenticated Google user can access the app. AuthStatus simplified to loading/authenticated/unauthenticated. Build passes.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes with zero errors
- [ ] `npm run build` succeeds
- [ ] `BusinessRole` includes `"owner" | "editor" | "viewer"`
- [ ] `BusinessInvite` simplified (no token, expiresAt, acceptedBy, acceptedAt)
- [ ] `InviteStatus` is `"active" | "revoked"`
- [ ] Six invite functions exist in business-firestore.ts (create, get, list, revoke, delete, accept)
- [ ] Firestore rules include viewer in read rules, exclude from write rules
- [ ] Firestore rules include `isOnlySelfAddToRoles` and `isValidInviteAcceptance`
- [ ] `ALLOWED_EMAILS` removed from entire codebase
- [ ] `AuthStatus` no longer includes `'denied'`
</verification>

<success_criteria>

- Viewer role available in type system
- Reusable invite data model (active/revoked, no single-use fields)
- Invite CRUD functions in Firestore service layer
- Security rules enforce viewer read-only + invite acceptance path
- No email whitelist — Firestore roles are sole access control
- Full TypeScript compilation and build pass
</success_criteria>

<output>
After completion, create `.planning/phases/09-sharing-access/09-01-SUMMARY.md`
</output>
