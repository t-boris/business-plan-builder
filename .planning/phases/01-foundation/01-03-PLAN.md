---
phase: 01-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified: [src/types/plan.ts, src/types/scenario.ts, src/types/index.ts, src/store/plan-atoms.ts, src/store/scenario-atoms.ts, src/store/derived-atoms.ts, src/lib/firestore.ts, src/lib/constants.ts]
autonomous: true
---

<objective>
Create the TypeScript type system for all business plan sections and scenarios, Firestore data model with subcollection read/write utilities, and Jotai atoms for state management.

Purpose: Establish the data layer that all section UIs and the what-if engine will build on — types define structure, Firestore persists data, Jotai atoms enable reactive state.
Output: Complete type definitions, working Firestore utilities, Jotai atoms with derived calculations for core business metrics.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TypeScript types for business plan sections and scenarios</name>
  <files>src/types/plan.ts, src/types/scenario.ts, src/types/index.ts</files>
  <action>
  1. Create `src/types/plan.ts` with interfaces for each of the 9 business plan sections:

     - **ExecutiveSummary**: summary text, mission, vision, keyHighlights string[]
     - **MarketAnalysis**: targetDemographic (age range, location, radius), marketSize, competitors array (name, pricing, strengths, weaknesses), demographics (population, languages, income)
     - **ProductService**: packages array (name, price, duration, maxParticipants, includes string[], description), addOns array (name, price)
     - **MarketingStrategy**: channels array (name: 'meta-ads' | 'google-ads' | 'organic-social' | 'partnerships', budget, expectedLeads, expectedCAC, description, tactics string[]), offers string[], landingPage object
     - **Operations**: crew array (role, hourlyRate, count), capacity (maxBookingsPerDay, maxBookingsPerWeek, maxBookingsPerMonth), travelRadius, equipment string[], safetyProtocols string[]
     - **FinancialProjections**: months array of { month, revenue, costs (breakdown: marketing, labor, supplies, museum, transport), profit }, unitEconomics (avgCheck, costPerEvent, profitPerEvent, breakEvenEvents)
     - **RisksDueDiligence**: risks array (category: 'regulatory' | 'operational' | 'financial' | 'legal', title, description, severity: 'high' | 'medium' | 'low', mitigation), complianceChecklist array (item, status: 'complete' | 'pending' | 'not-started')
     - **KpisMetrics**: targets object (monthlyLeads, conversionRate, avgCheck, cacPerLead, cacPerBooking, monthlyBookings), actuals (same shape, optional — for tracking)
     - **LaunchPlan**: stages array (name, startDate, endDate, tasks array (task, status: 'done' | 'in-progress' | 'pending'))

     Add a union type `BusinessPlanSection` and a `SectionSlug` type (string literal union of all section URL slugs).

     Create a `BusinessPlan` type that holds metadata (id, name, createdAt, updatedAt) and references to sections.

  2. Create `src/types/scenario.ts` with:
     - **ScenarioVariables**: All adjustable inputs — pricing per package, monthlyLeads, conversionRate, cacPerLead, monthlyAdBudget (per channel), crewCount, costPerEvent, bookingsPerMonth
     - **ScenarioMetadata**: id, name, description, createdAt, isBaseline boolean
     - **Scenario**: metadata + variables
     - **DerivedMetrics**: All computed values — monthlyBookings, monthlyRevenue, monthlyCosts, monthlyProfit, avgCheck, cacPerBooking, breakEvenMonths, annualRevenue, annualProfit

  3. Create `src/types/index.ts` that re-exports all types from plan.ts and scenario.ts.

  **Use TypeScript interfaces, not classes.** Keep them serializable (no methods) since they go to/from Firestore.
  **Do NOT** make types overly nested — keep them 2 levels deep max for Firestore compatibility.
  </action>
  <verify>npm run build succeeds, no TypeScript errors. Types can be imported via `@/types`.</verify>
  <done>All 9 section types defined, scenario variable + derived metric types defined, all exportable via @/types</done>
</task>

<task type="auto">
  <name>Task 2: Create Firestore subcollection utilities and Jotai atoms</name>
  <files>src/lib/firestore.ts, src/lib/constants.ts, src/store/plan-atoms.ts, src/store/scenario-atoms.ts, src/store/derived-atoms.ts</files>
  <action>
  1. Create `src/lib/constants.ts` with:
     - Default business data pre-populated from PROJECT.md:
       - DEFAULT_PACKAGES: 3 packages with all details (Ocean Starter $800, Ocean Explorer $980, Ocean VIP $1200)
       - DEFAULT_KPI_TARGETS: { monthlyLeads: 125, conversionRate: 0.20, avgCheck: 993, cacPerLead: 20, cacPerBooking: 85 }
       - DEFAULT_MARKETING_CHANNELS: Meta Ads, Google Ads, Organic Social, Partnerships with budgets
       - SECTION_SLUGS: array of all section URL slugs matching the router paths
       - SECTION_LABELS: Record mapping slugs to display names

  2. Create `src/lib/firestore.ts` with Firestore subcollection utilities:
     - Use modular Firebase API (doc, getDoc, setDoc, onSnapshot, collection)
     - `getSection(planId: string, sectionSlug: SectionSlug)` — reads a section document
     - `saveSection(planId: string, sectionSlug: SectionSlug, data: any)` — writes/merges section document
     - `subscribeToSection(planId: string, sectionSlug: SectionSlug, callback)` — real-time listener with onSnapshot
     - `getScenario(planId: string, scenarioId: string)` — reads scenario
     - `saveScenario(planId: string, scenario: Scenario)` — writes scenario
     - `listScenarios(planId: string)` — lists all scenarios for a plan
     - Firestore paths: `plans/{planId}/sections/{sectionSlug}` and `plans/{planId}/scenarios/{scenarioId}`
     - Use `{ merge: true }` for setDoc to enable partial updates

  3. Create `src/store/scenario-atoms.ts` with Jotai primitive atoms for scenario inputs:
     - One atom per adjustable variable (priceStarter, priceExplorer, priceVIP, monthlyLeads, conversionRate, cacPerLead, monthlyAdBudgetMeta, monthlyAdBudgetGoogle, crewCount, costPerEvent)
     - Initialize with defaults from constants.ts
     - Export `scenarioNameAtom` for the current scenario name

  4. Create `src/store/derived-atoms.ts` with Jotai derived (read-only) atoms:
     - `monthlyBookingsAtom` = monthlyLeads * conversionRate
     - `avgCheckAtom` = weighted average of package prices (assume equal distribution initially)
     - `monthlyRevenueAtom` = monthlyBookings * avgCheck
     - `totalMonthlyAdSpendAtom` = sum of all channel budgets
     - `cacPerBookingAtom` = totalMonthlyAdSpend / monthlyBookings
     - `monthlyCostsAtom` = (crewCount * hourlyRate * avgHoursPerEvent * monthlyBookings) + totalMonthlyAdSpend + (costPerEvent * monthlyBookings)
     - `monthlyProfitAtom` = monthlyRevenue - monthlyCosts
     - `annualRevenueAtom` = monthlyRevenue * 12
     - `annualProfitAtom` = monthlyProfit * 12
     - `profitMarginAtom` = monthlyProfit / monthlyRevenue

  5. Create `src/store/plan-atoms.ts` with Jotai atoms for business plan section data:
     - `currentPlanIdAtom` — stores the active plan ID (default: 'default')
     - `sectionDataAtom(sectionSlug)` — atom family pattern using a Map or individual atoms per section
     - Keep this simple for now — full Firestore sync will be wired in Phase 2

  **Use Jotai's `atom()` for primitives and `atom((get) => ...)` for derived.** Do NOT use useEffect for derived calculations.
  **Do NOT** over-engineer the Firestore sync — simple read/write/subscribe functions are sufficient. Full auto-save wiring happens in Phase 2 when section UIs are built.
  </action>
  <verify>npm run build succeeds. Import atoms in a test component to verify they resolve without errors.</verify>
  <done>Firestore utilities work with subcollection paths, all scenario atoms defined with correct derivation chain, plan atoms ready for section data, constants pre-populated with business data</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without TypeScript errors
- [ ] All types importable via `@/types`
- [ ] All atoms importable via `@/store/*`
- [ ] Firestore utilities importable via `@/lib/firestore`
- [ ] Constants contain correct business data from PROJECT.md
- [ ] Derived atoms compute correct values from defaults (e.g., 125 leads * 0.20 = 25 bookings)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Type system covers all 9 sections and scenario variables
- Firestore subcollection utilities ready for use
- Jotai atoms provide reactive derived calculations
- Default business data pre-populated from project requirements
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
