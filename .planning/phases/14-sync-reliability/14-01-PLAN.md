---
phase: 14-sync-reliability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/lib/sync-status.ts, src/store/sync-atoms.ts, src/lib/retry.ts, src/components/sync-status-indicator.tsx]
autonomous: true
---

<objective>
Create sync status infrastructure: shared types, Jotai atoms, retry utility, and UI indicator component.

Purpose: Foundation that all save hooks will use to report sync state and that the UI will consume to show save status to users.
Output: Sync status types, global atoms, retry helper, and SyncStatusIndicator component.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/logger.ts
@src/store/derived-atoms.ts
@src/components/business-header-bar.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sync status types and Jotai atoms</name>
  <files>src/lib/sync-status.ts, src/store/sync-atoms.ts</files>
  <action>
**src/lib/sync-status.ts** — Define types:

```typescript
type SyncState = 'idle' | 'saving' | 'saved' | 'error' | 'offline';

interface SyncEntry {
  domain: string;      // e.g. 'section', 'scenario', 'variables', 'profile'
  state: SyncState;
  error?: string;
  lastSaved?: number;  // Date.now() timestamp
}
```

Export the types and a helper `getSyncSummary(entries: SyncEntry[]): SyncState` that returns the worst state across all entries (error > saving > saved > idle).

**src/store/sync-atoms.ts** — Create Jotai atoms:

```typescript
// Map of domain -> SyncEntry
const syncEntriesAtom = atom<Record<string, SyncEntry>>({});

// Derived: overall sync state
const syncSummaryAtom = atom((get) => getSyncSummary(Object.values(get(syncEntriesAtom))));

// Writer atom: update a single domain's sync state
const updateSyncAtom = atom(null, (get, set, update: SyncEntry) => {
  set(syncEntriesAtom, { ...get(syncEntriesAtom), [update.domain]: update });
});
```

Export all atoms. Keep it simple — no middleware, no persistence.
  </action>
  <verify>npx tsc -b 2>&1 | grep -E "sync-status|sync-atoms" returns no errors</verify>
  <done>SyncState types exported. syncEntriesAtom, syncSummaryAtom, updateSyncAtom atoms created and exported.</done>
</task>

<task type="auto">
  <name>Task 2: Create retry utility with exponential backoff</name>
  <files>src/lib/retry.ts</files>
  <action>
Create a small retry utility for Firestore operations:

```typescript
interface RetryOptions {
  maxRetries?: number;   // default: 3
  baseDelay?: number;    // default: 1000ms
  maxDelay?: number;     // default: 10000ms
}

async function withRetry<T>(
  fn: () => Promise<T>,
  options?: RetryOptions
): Promise<T>
```

Implementation:
- Try `fn()`. On success, return result.
- On failure: if retries remain, wait `baseDelay * 2^attempt` (capped at maxDelay), then retry.
- After all retries exhausted, throw the last error.
- Use `createLogger('retry')` to log each retry attempt: `log.warn('retrying', { attempt, maxRetries, delay, error: err.message })`.

Under 30 lines. No external dependencies.
  </action>
  <verify>npx tsc -b 2>&1 | grep "retry" returns no errors</verify>
  <done>withRetry utility exported with exponential backoff and structured logging.</done>
</task>

<task type="auto">
  <name>Task 3: Create SyncStatusIndicator component</name>
  <files>src/components/sync-status-indicator.tsx</files>
  <action>
Create a minimal sync status indicator component that reads from `syncSummaryAtom` and `syncEntriesAtom`:

States displayed:
- `idle`: Nothing shown (invisible)
- `saving`: Small "Saving..." text with subtle pulse animation
- `saved`: "Saved" text that fades out after 2s (like existing BusinessHeaderBar pattern)
- `error`: Red "Save failed" text that persists until next successful save. On hover/click, show the error domain and message.
- `offline`: "Offline" text (detect via `navigator.onLine`)

Use existing Tailwind classes. Keep it minimal — a single `<span>` or small `<div>`. No toast library needed.

Add a `useOnlineStatus()` inline hook that listens to `window.addEventListener('online'/'offline')` and updates a local state.

When offline is detected, set a sync entry: `{ domain: 'network', state: 'offline' }`. When back online, clear it.

The component should be self-contained and ready to mount anywhere (layout shell, header bar, etc).
  </action>
  <verify>npx tsc -b 2>&1 | grep "sync-status-indicator" returns no errors</verify>
  <done>SyncStatusIndicator component renders correct state from sync atoms. Offline detection works.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx vite build` succeeds
- [ ] All 4 new files compile without TypeScript errors
- [ ] Types, atoms, retry utility, and component are all exported correctly
</verification>

<success_criteria>

- Sync status types defined (SyncState, SyncEntry)
- Global sync atoms created (entries, summary, updater)
- Retry utility with exponential backoff
- SyncStatusIndicator component ready to mount
- No build errors
</success_criteria>

<output>
After completion, create `.planning/phases/14-sync-reliability/14-01-SUMMARY.md`
</output>
