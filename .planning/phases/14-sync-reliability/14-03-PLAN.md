---
phase: 14-sync-reliability
plan: 03
type: execute
wave: 2
depends_on: ["14-01"]
files_modified: [src/hooks/use-scenario-sync.ts, src/app/providers.tsx]
autonomous: true
---

<objective>
Refactor useScenarioSync with sync status reporting and fix the providers.tsx load-failure race condition.

Purpose: Scenario auto-save failures must be visible. The VariableLoader/ScenarioSync load-failure path must not trigger blank baseline writes.
Output: useScenarioSync reports sync status. providers.tsx guards against writing on load failure.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/14-sync-reliability/14-01-SUMMARY.md
@src/hooks/use-scenario-sync.ts
@src/app/providers.tsx
@src/lib/sync-status.ts
@src/store/sync-atoms.ts
@src/lib/retry.ts
@src/lib/logger.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor useScenarioSync with sync status and logging</name>
  <files>src/hooks/use-scenario-sync.ts</files>
  <action>
Refactor useScenarioSync:

1. **Import**: `createLogger`, `withRetry`, `updateSyncAtom`.
2. **Add logger**: `const log = createLogger('scenario')`.
3. **Use sync atoms**: `const setSyncStatus = useSetAtom(updateSyncAtom)`.

4. **Wrap the save in the debounce callback**:
   ```
   setSyncStatus({ domain: 'scenario', state: 'saving' });
   try {
     await withRetry(() => Promise.all([
       saveScenarioData(businessId, currentId, scenario),
       saveScenarioPreferences(businessId, { activeScenarioId: currentId, scenarioList: updatedList })
     ]));
     setSyncStatus({ domain: 'scenario', state: 'saved', lastSaved: Date.now() });
     log.info('saved', { businessId, scenarioId: currentId });
     // Update scenarioList atom AFTER successful save
   } catch (err) {
     const message = err instanceof Error ? err.message : 'Scenario save failed';
     setSyncStatus({ domain: 'scenario', state: 'error', error: message });
     log.error('save.failed', { businessId, scenarioId: currentId, error: message });
   }
   ```

5. **Fix scenarioList dep array issue**: The current code updates `setScenarioList` inside the debounce callback, and `scenarioList` is in the `useEffect` deps. This can cause a re-trigger loop. Move the `scenarioList` update inside the successful save path but use a ref to track the last-saved list to avoid unnecessary re-triggers. Specifically: only update `setScenarioList` if the metadata actually changed (compare with previous).

Keep existing debounce timing (500ms). Preserve all guards (`syncReady`, `businessId`).
  </action>
  <verify>npx tsc -b 2>&1 | grep "use-scenario-sync" returns no errors</verify>
  <done>useScenarioSync reports sync status via atoms. Retries failed saves. Logs all save operations.</done>
</task>

<task type="auto">
  <name>Task 2: Fix providers.tsx load-failure race condition</name>
  <files>src/app/providers.tsx</files>
  <action>
Fix the dangerous pattern where VariableLoader and ScenarioSync set `loaded=true`/`syncReady=true` even on Firestore failure, which can trigger blank baseline writes:

1. **VariableLoader**: Replace the silent catch with structured logging. On catch, still set `loaded=true` (so the app doesn't hang) BUT also set a `loadFailed` flag:
   ```
   const [loadFailed, setLoadFailed] = useState(false);
   // in catch:
   log.warn('variables.load.failed', { businessId, error });
   setLoadFailed(true);
   ```

2. **ScenarioSync**: Add a guard to the "create baseline if none exist" path. Check that variables actually loaded successfully (not null AND not loadFailed). If variables failed to load, do NOT create a blank baseline — just log a warning and set syncReady=true without writing:
   ```
   if (scenarios.length === 0 && variables && !variableLoadFailed) {
     // Safe to create baseline
   } else if (scenarios.length === 0 && (!variables || variableLoadFailed)) {
     log.warn('baseline.skipped', { reason: 'variable load failed' });
     // Don't write blank baseline — just proceed with empty state
   }
   ```

3. **Pass loadFailed state**: Thread the `loadFailed` state from VariableLoader to ScenarioSync. The simplest approach: add a `variableLoadFailedAtom` to the store, or pass via a shared ref since both components are siblings in the same parent. Choose the least invasive approach that doesn't require restructuring the component tree.

4. **Add logging to ScenarioSync catch**: Replace the silent catch with `log.warn('scenarios.load.failed', ...)`.

Keep the component tree structure unchanged. Only add guards and logging.
  </action>
  <verify>npx vite build succeeds. No silent catches remain in VariableLoader or ScenarioSync.</verify>
  <done>Load failures no longer trigger blank baseline writes. All load errors are logged. Race condition eliminated.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx vite build` succeeds
- [ ] Scenario sync reports status to sync atoms
- [ ] providers.tsx VariableLoader failure does not trigger blank baseline
- [ ] No silent catch blocks remain in modified files
- [ ] Structured logging on all save and load operations
</verification>

<success_criteria>

- Scenario save failures visible via sync atoms
- Load-failure race condition fixed (no blank baseline writes)
- All operations logged with structured logger
- No build errors
</success_criteria>

<output>
After completion, create `.planning/phases/14-sync-reliability/14-03-SUMMARY.md`
</output>
