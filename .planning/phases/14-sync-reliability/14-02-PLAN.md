---
phase: 14-sync-reliability
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified: [src/hooks/use-section.ts, src/lib/business-firestore.ts]
autonomous: true
---

<objective>
Refactor useSection hook with sync status reporting, retry on save, and structured logging.

Purpose: useSection is the primary data persistence hook for all 9 section editors. Save failures must be visible and retried.
Output: useSection returns isSaving/saveError/lastSaved, uses retry, reports to sync atoms, logs with structured logger.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/14-sync-reliability/14-01-SUMMARY.md
@src/hooks/use-section.ts
@src/lib/business-firestore.ts
@src/lib/sync-status.ts
@src/store/sync-atoms.ts
@src/lib/retry.ts
@src/lib/logger.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add updatedAt to saveSectionData</name>
  <files>src/lib/business-firestore.ts</files>
  <action>
Modify `saveSectionData` to inject `updatedAt: new Date().toISOString()` into the data before saving, matching the pattern already used by `updateBusiness`.

This gives section documents a server-side timestamp for "last saved" indicators.

Do NOT modify any other functions in this file.
  </action>
  <verify>grep "updatedAt" src/lib/business-firestore.ts shows it in both updateBusiness and saveSectionData</verify>
  <done>saveSectionData now writes updatedAt alongside section data.</done>
</task>

<task type="auto">
  <name>Task 2: Refactor useSection with sync status, retry, and logging</name>
  <files>src/hooks/use-section.ts</files>
  <action>
Refactor useSection hook. Changes:

1. **Import dependencies**: `createLogger`, `withRetry`, `updateSyncAtom` from new modules.

2. **Add logger**: `const log = createLogger('section')`.

3. **Expand return type** — add to UseSectionReturn:
   - `isSaving: boolean`
   - `saveError: string | null`
   - `lastSaved: number | null` (Date.now() timestamp)

4. **Add state**: `const [isSaving, setIsSaving] = useState(false)`, `const [saveError, setSaveError] = useState<string | null>(null)`, `const [lastSaved, setLastSaved] = useState<number | null>(null)`.

5. **Refactor debounceSave**:
   ```
   setIsSaving(true);
   setSaveError(null);
   set(updateSyncAtom, { domain: 'section', state: 'saving' });
   try {
     await withRetry(() => saveSectionData(businessId, sectionSlug, newData));
     const now = Date.now();
     setLastSaved(now);
     set(updateSyncAtom, { domain: 'section', state: 'saved', lastSaved: now });
     log.info('saved', { businessId, section: sectionSlug });
   } catch (err) {
     const message = err instanceof Error ? err.message : 'Save failed';
     setSaveError(message);
     set(updateSyncAtom, { domain: 'section', state: 'error', error: message });
     log.error('save.failed', { businessId, section: sectionSlug, error: message });
   } finally {
     setIsSaving(false);
   }
   ```
   Use `useSetAtom(updateSyncAtom)` to get the setter.

6. **Fix unmount flush**: The current `try { saveSectionData(...) } catch {}` never catches async errors. Replace with: call `saveSectionData` and `.catch(err => log.warn('flush.failed', ...))` — acknowledge it's best-effort but at least log it.

7. **Refactor load error**: Replace silent catch with `log.warn('load.failed', { businessId, section: sectionSlug, error })`. Still fall back to defaults (correct behavior) but now logged.

8. **Return expanded interface**: Include `isSaving`, `saveError`, `lastSaved` in return object.

Preserve all existing behavior (debounce timing, canEdit guard, optimistic updates). Only add visibility, retry, and logging.
  </action>
  <verify>npx tsc -b 2>&1 | grep "use-section" returns no errors. npx vite build succeeds.</verify>
  <done>useSection reports save status via return value and sync atoms. Retries failed saves. Logs all operations.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx vite build` succeeds
- [ ] useSection returns isSaving, saveError, lastSaved
- [ ] Sync atoms updated on save/error
- [ ] No silent catch blocks remain in useSection
- [ ] Structured logging on save, error, load failure
</verification>

<success_criteria>

- useSection save errors are visible via return type and sync atoms
- Failed saves are retried with exponential backoff
- All operations logged with structured logger
- Unmount flush is properly logged on failure
- No build errors
</success_criteria>

<output>
After completion, create `.planning/phases/14-sync-reliability/14-02-SUMMARY.md`
</output>
