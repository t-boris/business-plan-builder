---
phase: 17-generic-product-service-offerings
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/plan.ts
  - src/types/index.ts
  - src/features/sections/product-service/normalize.ts
  - src/features/sections/product-service/normalize.test.ts
autonomous: true
---

<objective>
Define the new Offering-based domain model and create a backward-compatible normalization function that converts legacy `packages` data to the new `offerings` format.

Purpose: Foundation for the entire phase — all other plans depend on these types and the normalization utility.
Output: New TypeScript interfaces (Offering, AddOn v2, ProductService v2), normalization function with tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/types/plan.ts
@src/types/index.ts
@src/hooks/use-section.ts
@src/features/sections/product-service/index.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define new Offering-based types</name>
  <files>src/types/plan.ts, src/types/index.ts</files>
  <action>
Replace the existing Package, AddOn, and ProductService interfaces in `src/types/plan.ts` with:

```typescript
export interface OfferingImage {
  url: string;
  storagePath?: string;
  alt?: string;
}

export interface Offering {
  id: string;
  name: string;
  description: string;
  price: number | null;       // null = "on request"
  priceLabel?: string;         // e.g. "per hour", "per month", "from"
  addOnIds: string[];          // references to AddOn.id
  image?: OfferingImage;
}

export interface AddOn {
  id: string;
  name: string;
  description?: string;
  price: number;
  priceLabel?: string;         // e.g. "per unit", "one-time"
}

export interface ProductService {
  overview?: string;
  offerings: Offering[];
  addOns: AddOn[];
}
```

Remove the old `Package` interface entirely. Keep the old `Package` type exported as a deprecated alias for backward-compat in the normalization function only — actually NO, don't export it. The normalization function will define its own internal type for the legacy format.

Update `src/types/index.ts` barrel export to include `Offering`, `OfferingImage`, and remove `Package` if it was exported.

IMPORTANT: The old `Package` type is imported in `src/features/sections/product-service/index.tsx` — that file will be rewritten in Plan 03 so don't worry about breaking it. But do check if any other files import `Package` type and fix those imports (likely only the export files which will be updated in Plan 06, but may need temporary stubs to keep the build passing).

To keep the build passing during this intermediate state: if the product-service component or export files break due to the type change, add minimal `// @ts-expect-error` comments noting "Will be fixed in Plan 03/06". However, prefer keeping the build green by defining a `LegacyPackage` type locally in normalize.ts for the old format.
  </action>
  <verify>npx tsc --noEmit 2>&1 | head -30 — check for type errors (some expected in product-service/index.tsx and export files that will be rewritten later)</verify>
  <done>New Offering, AddOn, OfferingImage, ProductService types exported from src/types/. Old Package type removed from plan.ts.</done>
</task>

<task type="auto">
  <name>Task 2: Create normalization function with tests</name>
  <files>src/features/sections/product-service/normalize.ts, src/features/sections/product-service/normalize.test.ts</files>
  <action>
Create `src/features/sections/product-service/normalize.ts`:

Define a `LegacyPackage` interface internally (not exported from types):
```typescript
interface LegacyPackage {
  name: string;
  price: number;
  duration?: string;
  maxParticipants?: number;
  includes: string[];
  description: string;
}

interface LegacyAddOn {
  name: string;
  price: number;
}

interface LegacyProductService {
  packages?: LegacyPackage[];
  addOns?: LegacyAddOn[];
}
```

Export function `normalizeProductService(raw: unknown): ProductService`:

1. Cast `raw` to `Record<string, unknown>` safely
2. Check if `raw.offerings` exists and is an array → it's already new format, just ensure all offerings have `id` fields (generate via `crypto.randomUUID()` if missing)
3. Check if `raw.packages` exists and is an array → legacy format, convert:
   - Each Package → Offering: generate `id`, map `name`, `description`, `price`, set `priceLabel` from `duration` if present (e.g. `duration: "2 hours"` → `priceLabel: "2 hours"`), set `addOnIds: []`, fold `includes` array into description as bullet points (append to existing description with newline + "• " per item), no image
   - Each old AddOn → new AddOn: generate `id`, keep `name` and `price`, no description
4. If neither exists → return default empty `{ offerings: [], addOns: [], overview: '' }`
5. Preserve `overview` if present, default to `''`
6. Ensure all AddOns have `id` fields

Do NOT use `crypto.randomUUID()` directly — use a helper that falls back for test environments. Use `globalThis.crypto?.randomUUID?.() ?? Math.random().toString(36).slice(2)`.

Create `src/features/sections/product-service/normalize.test.ts` with tests:

1. "returns default for empty/null input"
2. "normalizes legacy packages to offerings" — 2 packages with includes, duration, maxParticipants → offerings with description containing bullet points, priceLabel from duration
3. "normalizes legacy addOns with id generation"
4. "passes through new-format data unchanged" — data with `offerings` array passes through
5. "handles mixed data (has both packages and offerings)" — offerings take precedence
6. "generates ids for offerings missing them"

Run tests with `npx vitest run src/features/sections/product-service/normalize.test.ts`.
  </action>
  <verify>npx vitest run src/features/sections/product-service/normalize.test.ts — all 6 tests pass</verify>
  <done>normalizeProductService function converts legacy Package-based data to Offering-based format. 6 tests passing.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] New types compile: `npx tsc --noEmit` (some errors in product-service/index.tsx and export files are expected — they'll be fixed in Plans 03, 05, 06)
- [ ] Normalization tests pass: `npx vitest run src/features/sections/product-service/normalize.test.ts`
- [ ] Types are exported from `src/types/index.ts`
</verification>

<success_criteria>
- Offering, AddOn, OfferingImage, ProductService interfaces defined and exported
- Old Package interface removed
- normalizeProductService handles: empty input, legacy packages, new offerings, mixed data
- 6 normalization tests passing
</success_criteria>

<output>
After completion, create `.planning/phases/17-generic-product-service-offerings/17-01-SUMMARY.md`
</output>
