---
phase: 16-ai-backend-proxy
plan: 02
type: execute
wave: 2
depends_on: ["16-01"]
files_modified: [src/lib/ai/gemini-client.ts, src/lib/ai/perplexity-client.ts, src/lib/ai/proxy-fetch.ts, .env.example]
autonomous: true
---

<objective>
Refactor frontend AI clients to call the Firebase Functions proxy instead of making direct API calls. Remove AI API keys from the client-side bundle.

Purpose: Complete the security migration — the frontend no longer holds or sends AI API keys.
Output: gemini-client.ts and perplexity-client.ts call proxy endpoints. VITE_GEMINI_API_KEY and VITE_PERPLEXITY_API_KEY removed from .env.example.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/16-ai-backend-proxy/16-01-SUMMARY.md
@src/lib/ai/gemini-client.ts
@src/lib/ai/perplexity-client.ts
@src/hooks/use-ai-suggestion.ts
@src/hooks/use-market-research.ts
@src/lib/firebase.ts
@.env.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared proxy fetch helper</name>
  <files>src/lib/ai/proxy-fetch.ts</files>
  <action>
Create `src/lib/ai/proxy-fetch.ts` — a shared helper for calling proxy endpoints with auth:

```typescript
import { auth } from '@/lib/firebase';
import { createLogger } from '@/lib/logger';

const log = createLogger('ai.proxy');

/**
 * Get the base URL for AI proxy endpoints.
 * In dev (emulator): http://localhost:5001/{projectId}/{region}
 * In prod: the Cloud Functions URL (auto-detected from hosting)
 */
function getProxyBaseUrl(): string {
  if (import.meta.env.DEV) {
    // Functions emulator — project ID must match .firebaserc
    const projectId = import.meta.env.VITE_FIREBASE_PROJECT_ID || 'my-business-planning';
    return `http://localhost:5001/${projectId}/us-central1`;
  }
  // In production, use relative URL (same-origin via Firebase Hosting rewrite)
  // OR use the full Cloud Functions URL
  return `https://us-central1-${import.meta.env.VITE_FIREBASE_PROJECT_ID}.cloudfunctions.net`;
}

export async function proxyFetch<T>(
  endpoint: string,
  body: Record<string, unknown>,
): Promise<T> {
  const token = await auth.currentUser?.getIdToken();
  if (!token) throw new Error('Not authenticated');

  const url = `${getProxyBaseUrl()}/${endpoint}`;

  log.info('request', { endpoint });

  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify(body),
  });

  if (!response.ok) {
    const errorText = await response.text();
    if (response.status === 401) throw new Error('Authentication required');
    if (response.status === 429) throw new Error('Rate limit reached, please wait a moment');
    log.error('response.error', { endpoint, status: response.status, error: errorText });
    throw new Error(`AI proxy error: ${response.status}`);
  }

  return response.json() as Promise<T>;
}
```
  </action>
  <verify>No TypeScript errors in the file.</verify>
  <done>Shared proxy fetch helper created with auth token, error handling, and dev/prod URL resolution.</done>
</task>

<task type="auto">
  <name>Task 2: Rewrite gemini-client.ts to use proxy</name>
  <files>src/lib/ai/gemini-client.ts</files>
  <action>
Rewrite `src/lib/ai/gemini-client.ts` to call proxy instead of Gemini SDK directly:

1. Remove `@google/genai` import and all direct Gemini SDK usage.
2. Import `proxyFetch` from `./proxy-fetch`.
3. Keep `isAiAvailable` — but change its logic. Since keys are now server-side, the client doesn't know if Gemini is configured. Options:
   - Always return `true` (let the server return an error if not configured)
   - Or check if user is authenticated (`auth.currentUser !== null`)
   - Simplest: `export const isAiAvailable = true;` — the proxy will handle the "not configured" error

4. Rewrite `generateSectionContent`:
```typescript
export async function generateSectionContent(
  prompt: string,
  systemInstruction: string,
): Promise<string> {
  const result = await proxyFetch<{ text: string }>('aiGeminiGenerate', {
    prompt,
    systemInstruction,
  });
  return result.text;
}
```

5. Rewrite `generateStructuredContent`:
```typescript
export async function generateStructuredContent<T>(
  prompt: string,
  systemInstruction: string,
  jsonSchema: object,
): Promise<T> {
  const result = await proxyFetch<{ data: T }>('aiGeminiStructured', {
    prompt,
    systemInstruction,
    jsonSchema,
  });
  return result.data;
}
```

6. Remove `@google/genai` from root `package.json` dependencies (it's now only in functions/).
  </action>
  <verify>grep -c "@google/genai" src/lib/ai/gemini-client.ts returns 0. No import of the Gemini SDK in client code.</verify>
  <done>gemini-client.ts calls proxy. No direct Gemini SDK usage in frontend.</done>
</task>

<task type="auto">
  <name>Task 3: Rewrite perplexity-client.ts to use proxy</name>
  <files>src/lib/ai/perplexity-client.ts</files>
  <action>
Rewrite `src/lib/ai/perplexity-client.ts` to call proxy instead of Perplexity API directly:

1. Remove the direct `fetch` to `https://api.perplexity.ai/chat/completions`.
2. Remove the `VITE_PERPLEXITY_API_KEY` env var reading.
3. Import `proxyFetch` from `./proxy-fetch`.
4. Set `isPerplexityAvailable = true` (server handles availability).

5. Rewrite `searchPerplexity`:
```typescript
export async function searchPerplexity(
  query: string,
): Promise<{ content: string; citations: string[] }> {
  return proxyFetch<{ content: string; citations: string[] }>('aiPerplexitySearch', {
    query,
  });
}
```
  </action>
  <verify>grep -c "VITE_PERPLEXITY_API_KEY" src/lib/ai/perplexity-client.ts returns 0. No direct API calls.</verify>
  <done>perplexity-client.ts calls proxy. No API key in client code.</done>
</task>

<task type="auto">
  <name>Task 4: Clean up env vars and deps, verify build</name>
  <files>.env.example, package.json</files>
  <action>
1. Update `.env.example`: Remove `VITE_GEMINI_API_KEY` and `VITE_PERPLEXITY_API_KEY` lines. Add a comment:
```
# AI keys are now server-side in Firebase Functions
# See functions/.secret.local for local dev setup
```

2. Remove `@google/genai` from root `package.json` dependencies (run `npm uninstall @google/genai`).

3. Run `npm install` to update lockfile.

4. Verify the full build pipeline:
   - `npm run lint` — should pass
   - `npx vitest run` — should pass (tests don't touch AI clients)
   - `npx vite build` — should succeed without @google/genai
   - `cd functions && npm run build` — should succeed

5. Verify no AI API key references remain in client source:
   - `grep -r "VITE_GEMINI_API_KEY" src/` — should return nothing
   - `grep -r "VITE_PERPLEXITY_API_KEY" src/` — should return nothing
   - `grep -r "api.perplexity.ai" src/` — should return nothing
  </action>
  <verify>All 4 build steps pass. No AI API key references in src/.</verify>
  <done>AI keys removed from client. Build passes. Frontend is clean.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx vite build` succeeds
- [ ] `cd functions && npm run build` succeeds
- [ ] No `VITE_GEMINI_API_KEY` or `VITE_PERPLEXITY_API_KEY` in src/
- [ ] No `@google/genai` import in src/
- [ ] No direct `api.perplexity.ai` calls in src/
- [ ] `npx vitest run` passes all tests
- [ ] `npm run lint` passes
</verification>

<success_criteria>

- Frontend AI clients call proxy endpoints via proxyFetch
- Firebase Auth ID token sent with every proxy request
- No AI API keys in client-side code or env vars
- @google/genai removed from root package.json
- Full build pipeline passes (lint, test, build)
- Functions build passes
</success_criteria>

<output>
After completion, create `.planning/phases/16-ai-backend-proxy/16-02-SUMMARY.md`
</output>
