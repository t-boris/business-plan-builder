---
phase: 13-observability-and-docs
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/lib/logger.ts, .gitignore, .env.example]
autonomous: true
---

<objective>
Create unified structured logging module and fix secrets exposure in .gitignore.

Purpose: Establish the observability foundation that all subsequent phases (sync reliability, tests, AI proxy) will use. Fix the critical .env gitignore gap before any accidental commit.
Output: src/lib/logger.ts module with structured logging, .gitignore secured.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/firebase.ts
@src/globals.d.ts
@.gitignore
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix .gitignore secrets exposure</name>
  <files>.gitignore</files>
  <action>
Add `.env` to .gitignore (currently only `*.local` is covered, `.env` itself is not). Place it in the existing Firebase section. Also add `firestore-debug.log` and `firebase-debug.log` explicitly for clarity even though `*.log` already covers them.

Verify .env is untracked with `git status`. If .env was already tracked, `git rm --cached .env` to untrack it without deleting the file.
  </action>
  <verify>git status shows .env is NOT in untracked or modified list (ignored). grep ".env" .gitignore returns a match.</verify>
  <done>.env is gitignored. No secrets can be accidentally committed via git add.</done>
</task>

<task type="auto">
  <name>Task 2: Create structured logging module</name>
  <files>src/lib/logger.ts</files>
  <action>
Create `src/lib/logger.ts` — a thin structured logging module. Requirements:

1. **Log levels**: `debug`, `info`, `warn`, `error` — each maps to corresponding console method.
2. **Structured format**: Every log entry is a JSON-serializable object with:
   - `level`: string
   - `event`: string (e.g. "section.save.error", "ai.request.start", "scenario.sync.fail")
   - `timestamp`: ISO string
   - `version`: from `__APP_VERSION__` global
   - `data`: optional Record<string, unknown> for contextual data
3. **Domain loggers**: Export a `createLogger(domain: string)` factory that returns a logger with the domain prefix baked in. Example: `createLogger('section')` produces events like `section.save.error`.
4. **Output**: In dev mode (`import.meta.env.DEV`), use console methods with human-readable format. In production, use `console.log` with JSON string for future log aggregation.
5. **No external dependencies** — pure console-based, no Sentry or external services.
6. **Export convenience instances**: `logger` (general), plus domain-specific loggers can be created inline by consumers.

Interface:
```typescript
interface Logger {
  debug(event: string, data?: Record<string, unknown>): void;
  info(event: string, data?: Record<string, unknown>): void;
  warn(event: string, data?: Record<string, unknown>): void;
  error(event: string, data?: Record<string, unknown>): void;
}
```

Keep it minimal — under 60 lines. No over-engineering. The point is to replace scattered console.error calls with structured events that can be searched and filtered.
  </action>
  <verify>TypeScript compiles: npx tsc --noEmit src/lib/logger.ts (or full project build)</verify>
  <done>logger.ts exists, exports createLogger factory and default logger instance. All log levels produce structured output.</done>
</task>

<task type="auto">
  <name>Task 3: Instrument critical error paths with logger</name>
  <files>src/lib/ai/gemini-client.ts, src/lib/ai/perplexity-client.ts, src/lib/formula-engine.ts</files>
  <action>
Replace existing console.error/console.warn calls with structured logger in the lib layer (NOT hooks yet — Phase 14 handles hooks):

1. **gemini-client.ts**: Add `const log = createLogger('ai.gemini')`. Log on error catch: `log.error('request.failed', { action, model, error: err.message })`. Log rate-limit detection: `log.warn('rate-limited', { action })`.

2. **perplexity-client.ts**: Add `const log = createLogger('ai.perplexity')`. Same pattern: log errors and rate limits with structured data.

3. **formula-engine.ts**: Replace `console.warn` with `const log = createLogger('formula')` and `log.warn('evaluation.error', { id, formula, error })`.

Do NOT touch hooks (use-section, use-scenario-sync) — those are Phase 14 scope. Only instrument the lib/ layer here.
  </action>
  <verify>npm run build succeeds. grep -r "console\." src/lib/ai/ src/lib/formula-engine.ts returns no raw console calls in these files.</verify>
  <done>AI clients and formula engine use structured logger. No raw console calls remain in instrumented files.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] .env is in .gitignore
- [ ] src/lib/logger.ts exists and exports createLogger + logger
- [ ] No raw console.error/warn in src/lib/ai/*.ts or src/lib/formula-engine.ts
</verification>

<success_criteria>

- .gitignore covers .env
- Structured logger module created with domain factory pattern
- AI clients and formula engine instrumented with structured logging
- No build errors introduced
</success_criteria>

<output>
After completion, create `.planning/phases/13-observability-and-docs/13-01-SUMMARY.md`
</output>
